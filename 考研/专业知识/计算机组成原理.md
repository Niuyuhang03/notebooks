# 计算机系统概述
+ 加速比是不加速/加速
+ 磁盘内圈外圈的数据传输率本来相同，使用zbr技术后，外圈高于内圈

## 计算机系统的基本组成与层次结构  
+ 电子计算机4代发展：电子管-晶体管-中小规模集成电路-超大规模集成电路
+ 早期冯诺依曼机
    + 由于运算器和控制器分离，存储器容量小，故以==**运算器**==为中心。工作基本方式为==控制流或指令流==驱动。数据和指令存在相同存储器中，由==控制器的控制单元CU==以==周期==区分。基本思想为==存储程序==（指令以代码形式存入存储器，逐条执行直至结束）
    + 软硬件功能在逻辑上==等效但不等价==，硬件效率高，软件灵活。软件+硬件构成完整计算机系统
    + 5大部件（==运算器、存储器、控制器、输入设备、输出设备==）：运算器、控制器组成CPU，运算器、控制器、存储器组成主机。注意MDR、MAR、高速缓存cache、通用寄存器在CPU中。地址译码器在主存中。5大部件分为两类：控制部件（控制器）和执行部件（运算器、存储器、输入设备、输出设备）
        + 运算器：
            + 算术逻辑单元ALU
            + 通用寄存器：MQ乘商寄存器、X操作数寄存器、ACC累加器、变址寄存器、基址寄存器
            + ==程序状态寄存器PSW（标志寄存器）==（保存跳转指令判断结果，即溢出、符号、进位借位等）
            + 移位器：乘除、移位
        + 存储器：分为主存（即内存）和辅存（即外存，如硬盘）
            + 地址寄存器MAR：存放欲访问的存储单元地址，经过地址译码器后找到存储单元。MAR长度为存储单元个数，如4M\*1B的$4M=2^{22}$，即22位
            + 地址译码器将找到的数据送到MDR
            + 存储体
            + 数据寄存器MDR：存放存储单元取出的数据。MDR长度为一个存储单元中数据长度，如4M\*1B的1B=8b，即8位
            + 时序控制逻辑产生时序信号
        + 控制器：
            + 程序计数器PC：存放下一条指令的在主存中的==地址==，送到MAR
            + 指令寄存器IR：指令寄存器存放欲执行的==指令==，其内容来自MDR
            + 控制单元CU：包含指令译码器ID，只译操作码OP，不译地址码
+ 现代计算机：由于I/O设备和CPU速度差距悬殊，故以==**存储器**==为中心，仍遵循冯诺依曼的==存储程序==思想
+ 应用软件和系统软件
    + 应用软件：如数据库系统
    + 系统软件：如操作系统、==数据库管理系统、编译器==
+ 翻译 $\begin{cases}编译：高级语言\rightarrow目标语言（汇编或机器），汇编：汇编语言\rightarrow机器语言，\\解释：边翻译边执行，不生成目标代码文件，运行速度慢\end{cases}$
+ 计算机层级结构：
    + 应用层
    + 高级语言机器：编译
    + 汇编语言机器：汇编
    + 操作系统机器：机器语言解释操作系统
    + 机器语言机器：微程序解释机器语言
    + 微指令机器：硬件执行微指令

## 计算机系统性能指标
+ 机器字长：==计算机进行一次整数运算所能处理二进制数位数，如32位计算机中的32位==，一般等于寄存器大小，决定计算精度。32位计算机则机器字长32位，求64位数相加要计算低32位和高32位两次
+ 指令字长：一个指令字中包含二进制代码位数
+ ==存储字长：一个存储单元中数据长度，MDR位数==。如4M\*1B的1B=8b，即8位
+ 数据字长（数据通路带宽）：数据总线一次能并行传送信息位数
+ ==主存容量：$2^{MAR位数}*MDR位数$==，MAR位数表述存储单元个数，MDR位数表示可寻址范围。如64K\*32位
+ 运算速度：
    + 吞吐量：单位时间内处理请求数量。可以综合反映计算机性能
    + 响应时间：包括CPU时间和等待时间
    + 延迟
    + CPU时钟周期：主频的倒数，CPU中最小时间单位。每个动作至少1个时钟周期
    + 主频：CPU时钟周期的倒数，衡量机器速度的主要参数，1Hz表示每秒1次。而CPU周期则是机器周期，是多个CPU时钟周期
    + CPI：Clock cycle Per Instruction执行一条指令的时钟周期数
    + CPU执行时间：CPU时钟周期数/主频=（指令条数\*CPI）/主频=指令条数\*CPI\*CPU时钟周期
    + MIPS：Million Instructions Per Second每秒执行几个百万条指令=指令条数/执行时间/$10^6$\===主频/CPI==
    + ==MFLOPS==：Mega Floating-point Operations Per Second==每秒执行几个百万次浮点运算===浮点操作次数/执行时间/$10^6$
    + GFLOPS：Giga Floating-point Operations Per Second每条执行几个十亿次浮点运算=浮点操作次数/执行时间/$10^9$
    + TFLOPS：Tera Floating-point Operations Per Second每秒执行几个万亿次浮点运算=浮点操作次数/执行时间/$10^{12}$

## 零碎知识点
+ 兼容指计算机软件==或==硬件的通用性，系列机指令系统==向后兼容==，即兼容旧的指令系统
+ 相联存储器可以按地址寻址，也可按==内容==寻址
+ ==透明指看不见==，无法操作。因此==IR、MAR、MDR透明==，而 ==**PC、通用寄存器、状态寄存器**不透明==，程序员可以操作。
+ 用于科学计算的计算机主要评估浮点数性能，因此MFLOPS更能反应性能
+ 当前高性能计算机设计的重要途径为采用并行处理技术
+ 磁盘驱动器是同时具有输入输出功能的装置
+ 外围设备是用户和计算机通信的界面，即输入设备、输出设备、外存储设备、多媒体设备、网络设备等
+ 同样程序在CPI相等、主频相等的计算机上运行，速度无法比较。因为指令数不一定相同

# 数据的表示和运算

## 数制与编码
+ 10进制转任意（k）进制：辗转相除法。==整数部分每次除以k==，每一步==余数倒序组合==。==小数部分每次乘以k==，每一步==整数部分为每步结果==，==乘积大于1时减1==，正序组合，乘积为1.0时结束
![10进制转2进制](https://i.loli.net/2019/09/05/W2TYhPrA4nypxbq.png)
+ BCD码：每用四位二进制数表示10进制中的0-9，必有6个冗余
    + 8421码：权重分别为8、4、2、1，==当计算结果大于等于10即$(1010)_2$时，要再加6即$(0110)_2$==
    + 余3码：==8421上再加3即$(0011)_2$==
    + 2421码：==要求大于等于5的数首位为1==。如5：1011，6：1100
+ ASCII码：==7位==，共128个
+ 大端存储和小端存储：如0x12345678
    + 小端存储：先存低位字节，后存高位字节，==78、56、34、12==
    + 大端存储：先存高位字节，后存低位字节，==12、34、56、78==
    
    | 地址偏移 | 大端模式 | 小端模式 |
    | :------: | :------: | :------: |
    |   0x00   |    12    |    78    |
    |   0x01   |    34    |    56    |
    |   0x02   |    56    |    34    |
    |   0x03   |    78    |    12    |
+ 码矩：任何两个合法码字之间最少变化的二进制位数，码距==大于等于2时可以检错==，码矩越大检错纠错越强，检错能力不小于纠错能力
+ 校验码：
    + 奇偶校验码：在编码前添加一个二进制位，使==信息+校验的1的个数为奇数（偶数）==则为奇（偶）校验码。可==检测奇数位出错==，==不能纠错==
    + 海明校验码：==检错d位，需要码距d+1。纠错d位，需要码距2d+1==。在信息位n=4，校验位k=3时，求信息$D_4D_3D_2D_1$的海明码过程，==王道计组P33页20题==
        + 首先确定海明码位数。满足 ==$2^k\ge$n+k+1==，则nk有效。设校验位$P_3P_2P_1$，海明码$H_7H_6H_5H_4H_3H_2H_1$
        + 确定校验位分布。$P_i$放在$H_{2^{i-1}}$上剩下位依次放信息位。得到$D_4D_3D_2P_3D_1P_2P_1$
        + 分组。校验位无需被校验，信息位满足：校验$H_i$的所有校验位的海明位之和。如$H_3$被$H_1H_2$校验
        + 校验位取值。$P_i$的值为所有被$P_i$校验过的信息取异或
        + ==校验==：对每个$P_i$和其校验的所有信息取异或，结果为0则正确
    + 冗余循环CRC校验码：==可检错纠错==，求K位信息后拼R位校验码过程，==王道计组P33页20题==
        + 根据最高次为R次的生成多项式（共R+1项），信息码左移==R==位，低位补零==（而不是R+1）==
        + 模二除法（异或），余数首位为1则商1，否则商0并除数右移一位。==余数作为校验位==
        + ==检验==：对K+R位做生成多项式的模二除法，余0则正确

## 定点数
+ 定点数：小数点位置固定
    + 定点小数（纯小数）：小数点在符号位之后，有效数值之前。范围$[-(1-2^{-n}), 1-2^{-n}]$
    + 定点整数（纯整数）：小数点在有效数值之后，范围$[-(2^n-1), 2^n-1]$
+ 原码：纯小数$[x]_原=\begin{cases}x&0\leq x\lt 1\\1+|x|&-1\lt x \leq 0\end{cases}$，n+1位表示范围$[-(1-2^n),1-2^n]$。纯整数$[x]_原=\begin{cases}0,x&0\leq x\lt 2^n\\2^n+|x|&-2^n\lt x \leq 0\end{cases}$，即负数时为符号位+有效数，n+1位表示范围$[-(2^n-1),2^n-1]$
+ 反码：负数时符号位==以后==的部分按原码取反，==符号位不变==。纯小数$[x]_原=\begin{cases}x&0\leq x\lt 1\\2-2^{-n}-|x|&-1\lt x \leq 0\end{cases}$，1+n位表示范围$[-(1-2^n),1-2^n]$。 纯整数$[x]_原=\begin{cases}0,x&0\leq x\lt 2^n\\2^{n+1}-1-|x|&-2^n\leq x \lt 0\end{cases}$，n+1位表示范围$[-(2^n-1),2^n-1]$
+ 补码：负数时反码按反码加一。纯小数$[x]_原=\begin{cases}x&0\leq x\lt 1\\2-|x|&-1\leq x \lt 0\end{cases}$，1+n位表示范围$[-1,1-2^n]$。 纯整数$[x]_原=\begin{cases}0,x&0\leq x\lt 2^n\\2^{n+1}-|x|&-2^n\leq x \leq 0\end{cases}$，==1+n位表示范围$[-2^n,2^n-1]$==
+ 移码：$[x]_移=x+2^n$。==移码符号位取反就是补码==。移码求原码时，直接减去01111...B即可，相当于减去10000....B再加1
![定点数](https://i.loli.net/2019/09/05/wU1cxDuVCMytEhk.png)
+ 运算
    + 移位
        + 算数移位：对有符号数操作，==符号位不变，对真值补0==，推原反补码
            + 正数：补0
            + 负数：原码补0，反码补1，==补码右移补1，左移补0==
        + 逻辑位移：对无符号数操作，丢弃，填0
        + 循环移位：用于低字节和高字节互换
            + 带进位位：溢出部分先进标志寄存器（程序状态字寄存器）
            + 不带进位位：溢出部分补空缺，并进入标志寄存器
    + 原码加减法：==符号位不参与运算==，丢弃溢出
        + 加法：同号直接加。异号改做减法，绝对值大的减去绝对值小的，符号单独判断
        + 减法：改为加法
    + 补码加减法：==符号位参与运算==，丢弃溢出
        + 加法：直接相加
        + 减法：==**减数真值取反，求补码后做加法**==
    + 符号扩展：补法类似算术移位，对真值补0后推原反补码
    + 补码的溢出：减法转化为加法。由于正+负和负+正永远不会溢出，因此溢出仅可能为正+正和负+负两种：
        + ==采用一位符号位：参与运算数符号相同，与结果不同则溢出==
            + 如果$C_s\bigoplus C_1=0$即符号位进位和最高位进位相同，不溢出，否则溢出
            + 若$A_sB_s \overline{S_s}+\overline{A_s}\overline{B_s}S_s=0$则在AB同号时答案与之同号，不溢出，否则溢出
        + ==双符号位：00 11不溢出，01正溢，10负溢==
    + N+1位乘法
        + ==原码一位乘法==：==过程P42例2.7==，==符号位用异或单独计算==。将被乘数和乘数取绝对值，积和被乘数取双符号位，乘数取无符号位，从乘数最低位开始判断，是1则积加上被乘数的绝对值并右移1位，是0则直接右移。==共有N次相加和N次右移==
        + ==补码一位乘法==：booth法，==符号位参与计算。共有N+1次相加和N次右移==
    + 除法
        + 原码除法：不恢复余数法，==N+1或N+2次相加和N次左移==
        + 补码除法：加减交替法，==N+1次相加和N次左移==
    + 强制类型转换：
        + 长->短：截断保留低位
        + 短->长：扩展，正数补0，负数补F，无符号补0

## 浮点数
+ 尾数为原码时，正数为0.1xxx，负数为1.1xxx
+ 尾数为补码时，正数为0.1xxx，负数为1.0xxx。双符号位为00.1xxx,11.0xxx
+ IEEE754标准：阶码为移码，尾数为==隐藏整数位1的原码==
    + float：==1位数符S+8位阶码E+23位尾数M=32位==，尾数实际为24位数。==真值为$(-1)^s*1.M*2^{E-127}$==。最大表示$(2^{8-1}-1)*(2-2^{-23})$。127即对E减去$0111\ 1111$，即减去$1000\ 0000$再加$1$得到真实阶
    + double：==1位数符S+11位阶码E+52位尾数M=64位==，尾数实际为53位数。真值为$(-1)^s*1.M*2^{E-1023}$。最大表示$(2^{11-1}-1)*(2-2^{-52})$
+ 定点数精度高，浮点数范围大，可表示数的个数一样多；基数大时，范围大，精度低（稀疏）

![单精度浮点数](https://i.loli.net/2019/09/05/afPjF8ulgU4LZoe.png)
+ 10进制转补码非规格化浮点数：10进制写成尾数/2^n格式，分别求补码。注意尾数应化为+0.1xxx或-0.1xxx格式
+ ==规格化：指数（float中为8位）不全为0==
+ 单精度浮点数求十进制、十进制求单精度浮点数：数符1位，阶码8位，尾数23位。其中阶码的移码可减去最高位1再加一，或直接求十进制后减去127。注意尾数为原码，省略整数部分1
+ char->int->long->double和float->double转换过程没有损失
+ char占1B
+ 浮点数补码加减法：
    + ==对阶==：统一为==大==阶
    + ==尾数加减==，注意尾数应带符号，根据原码加减法计算
    + ==规格化==：阶码溢出时右规1次，其他不满足规格化情况左规多次
    + 根据阶码==判断溢出==
+ 浮点数规格化为了增加浮点数表示==精度==

## 算术逻辑单元ALU
+ 一位全加器：和$S_i=A_i\bigoplus B_i\bigoplus C_{i-1}$，进位$C_i=A_iB_i+(A_i\bigoplus B_i)C_i$
+ 串行加法器
+ 并行加法器：加快进位产生和传递最能提高并行加法器速度
    + 串行进位
    + 并行进位

## 零碎知识点
+ 不是任何10进制小数都能转2进制，如0.3
+ ==C语言int占4字节，short占2字节==。计算机中==有符号数以补码保存==
+ ==补码和移码的0表示唯一==，==补码1.000的原码是-1==
+ 模4补码虽然有两个符号位，但两个相同，存储时只存一个，送入ALU时才传2个
+ ==正数反码补码不变==！
+ 计算机中，x=a+b，无论ab有无符号，都视作符号补码计算，再根据x有无符号进行解读
+ 进位标识符CF即相加后有没有(1)，而溢出标识符OF要看是否溢出（即同号相加时结果符号是否一致）
+ 定点小数要写成x.xxxxxxx，不能忽略符号

# 存储器层次结构

## 存储器的层次化结构
+ 存储器分类：
    + 按作用：
        + 主存储器：容量小，速度快，价格高。如内存条
        + 辅助存储器：容量大，速度慢，价格低。如ssd，hdd，光盘，软盘
        + 高速缓冲存储器Cache：容量小，速度快，价格高
    + 按存储介质：
        + 磁表面存储器
        + 光存储器
        + 磁芯存储器半导体存储器
    + 按存取方式：
        + 随机存储器RAM：随机存取，存取时间与存储单元物理位置无关
        + 只读存储器ROM：随机存取，断电不丢失，只读不能写（有些ROM也可以写）
        + 串行访问存储器：按物理位置先后顺序寻址
            + 顺序存储存储器SRAM：磁带
            + 直接存取存储器DRAM：磁盘（相比于顺序，直接属于部分串行）
    + 按断电后可保存性：
        + ==易失性存储器：如RAM==
        + ==非易失性存储器：如ROM==、磁表面、光
        + 破坏性读出：如DRAM
        + 非破坏性读出：如SRAM
+ 存储器性能指标：
    + 存储容量：存储容量相关中K、M、G为二进制，即2的10、20、30次方
    + 单位成本
    + 存储速度
        + ==存取时间$T_a$=读出时间+写入时间，即一次存储器操作的时间== 
        + ==存取周期$T_m$：一次完成读写操作的全部时间，即两次连续读或写的最小时间间隔，$T_m=T_a$+恢复内部状态时间$> T_a$==
        + 主存带宽$B_m$
+ 多级存储系统
    + ==速度、容量、价格排序：寄存器->Cache->主存->磁盘->磁带、光盘==
    + 多级存储系统为解决容量速度和价格的矛盾，主要有==Cache-主存层==和==主存-辅存层==。分别解决==CPU和主存速度不匹配问题==和==存储系统容量问题==。其中CPU可以直接和Cache、主存交换信息。==辅存则要通过主存和CPU交换信息==。
    ![多级存储系统](https://i.loli.net/2019/09/12/TbG67mc2AySVatv.jpg)
+ 虚拟存储系统中，CPU和主存的数据调动由硬件完成，对所有程序员透明。主存和辅存之间的调动由硬件和操作系统完成，只对应用程序员透明

## 半导体随机存储器

### 半导体存储芯片结构
+ 半导体存储芯片结构：存储矩阵、译码驱动、读写电路、读写控制线、片选线、地址线、数据线
+ 地址线n根，数据线m根，则芯片容量$2^n*m$位
+ 74138译码器

### 随机存储器RAM：用户区、OS工作时会加载到RAM
+ ==易失性存储器，随机存取==
+ 静态RAM：==如Cache==
    + 存储原理为==触发器==，存储元为双稳态触发器
    + 速度快，功耗大，集成度低
    + ==非破坏性读出==
    + 静态即==无需刷新==，只要通电就不丢失
    + 芯片容量$2^n*m$位，则地址线n根，数据线m根，片选1根，读控制线1根，写控制线1根（读写可合并）
+ 动态RAM：==如主存==
    + 存储原理为==电容储存电荷==，存储元为栅极电容
    + 速度慢，功耗小，集成度高
    + 采用==地址复用技术，地址线为原来的一半==，地址信号分行列两次输传送
    + ==破坏行读出==
    + ==由于存储电荷的电容放电，电容上电荷不能维持超过2ms，需要约每2ms以**行**为单位刷新==，如64*64的矩阵刷新，存取周期是0.5us，刷新周期为2ms
        + 集中刷新：有死时间，==1个存取周期0.5us内刷新1行，共64\*0.5us==
        + 分散刷新：没有死时间，==系统存取周期=2\*芯片存取周期，共64\*1us==
        + 异步刷新（集中分散相结合）：降低死时间，2ms内刷新所有x行，==每$\frac{2ms}{64}$刷新一行==
    + 芯片容量$2^n*m$位，则地址线n/2根，数据线m根，行通选1根，列通选1根，读控制线1根，写控制线1根（无片选，读写可合并）
+ 读写周期

### 只读存储器ROM：系统程序区
+ ==非易失性存储器，随机存取==，写比读慢（写入需要先擦除）
+ 掩膜式只读存储器==MROM：厂家写入后无法改变内容==
+ 一次可编程只读存储器==PROM：允许用户写入一次后，无法改变==
+ 可擦除可编程只读存储器==EPROM：可以多次改写==，但写入速度慢
+ 闪速存储器==Flash Memory：可以快读擦写==，瞬时启动，如U盘
+ 固态硬盘==SSD：可以快速擦写==，读写速度快

## 主存和CPU的连接
+ 主存通过数据总线、地址总线和控制总线与CPU连接：
    + 数据总线位数和频率的乘积正比于数据传输率
    + 地址总线位数决定可寻址的最大内存空间
    + 控制总线之初总线周期类型和本次操作完成时刻
+ 主存容量扩展
    + ==位扩展：增加存储字长==，多个存储芯片连接，来扩展存储芯片数据位数为CPU数据线数。如==8片8K\*1位RAM组成8K\*8位存储器==
        + 地址端、片选端、读写控制端并联
        + 数据端引出
    + ==字扩展：增加存储字的数量==。如==4片16K\*8位RAM组成64K\*8位存储器==
        + 地址端、数据端、读写控制端并联
        + 片选区分芯片
    + ==字位同时扩展：既增加存储字数量，又增加存储字长==。如8片16K\*4位RAM组成64K\*8位存储器
        + 地址端并联
        + 数据端引出，片选端区分芯片
+ 片选信号的产生：由CPU地址线 ==高位（如$A_{15}$）作为片选信号$\overline{CS}$==，低位用于片内寻址
    + ==线选法==：CPU高位地址线分别接到每一个芯片的片选端，==高n位选n片==
        + 优点：无需地址译码器
        + 缺点：地址空间不连续，选片的地址线必须分时为低电平，不能充分利用存储器空间造成浪费
    + ==译码片选法==：CPU高位地址线经过译码器，接到每一个芯片的片选端，==高n位选$2^n$片==
+ 存储器与CPU的连接
    + 选芯片：
        + ROM存放系统程序、常数
        + RAM存放用户编程程序
    + 地址线连接：CPU地址线一般多于芯片地址线
        + CPU低位地址线与芯片地址线相连，用于片内寻址
    + 数据线相连：芯片扩位
    + 读写命令线连接：一条或两条
    + 片选线连接：
        + CPU高位地址线产生片选信号，与译码器、芯片片选端相连
        + CPU访存信号MREQ与片选信号有关，只有CPU要求访存时才选中芯片，CPU访问IO时不要求存储器工作

## 双端口RAM和多模块存储器：提高CPU访问存储器速度

### 双端口RAM
+ 空间并行，提高访存速度
+ 一个存储器左右有两个独立端口，分别由两组地址线、数据线、读写控制线，允许两个CPU同时异步访问存储单元
+ 解决写入错误（同时写）和读出错误（一个读一个写）：延时一个端口

### 多模块存储器
+ 时间并行，提高访存速度
+ 单体多字存储器
    + 一个存取周期内，从同一地址取出m条指令，逐条送至CPU执行
    + 增大带宽，提高访存速度
    + 指令和数据必须连续存放，遇到转移指令等效果差
+ 多体并行存储器
    + 高位交叉编址：高位表示体号，低位体内地址（顺序方式）
        + 多体并行响应多个源的请求，提高访存速度
        + 连续存取m个字的时间$t=T*m$
        + 顺序存放，不满足程序的局部性原理
    + 低位交叉编址：低位体号，高位体内地址（交叉方式）
        + 存取周期不变时提高了存储器带宽，提高访存速度
        + 交叉模块数m有$m>=T/r$，其中T为存取周期，r为总线传送周期
        + 连续存取m个字的时间$t=T+(m-1)*r$。当流水线运行时，m很大，则t/m接近于r，即每r读取1个字，每T读取m个字
        + 交叉存放，满足程序的局部性原理

## 高速缓冲寄存器：解决系统速度
+ 程序访问的局部性原理：程序对主存的访问是不均匀的
    + 时间局部性：未来要用的信息很可能是现在正在使用的信息
    + 空间局部性：未来要用的信息很可能与现在正在使用的信息在存储空间上邻近
+ Cache读基本原理
    + 解决CPU和主存之间速度匹配问题 
    + 由==SRAM==构成
    + Cache保存主存中最活跃部分的副本
    + 若CPU发出读请求，根据块号查==Cache块（即Cache行）== 中对应主存标记位是否相同，相同再看有效位是否为1，若Cache命中，直接以==字==为单位读Cache；Cache未命中，以==Cache块==为单位将主存字所在块调入Cache，以字为单位调入CPU，主存的标记位存入Cache块的主存标记位中，有效位置1，然后访问cache。==**默认读cache和读内存是先后关系**==
    + 标记列阵中标记项个数为每Cache块一个标记项
+ Cache和主存的地址映射方式：地址映射指把存放在主存中的程序按照某种规则装入Cache，由==硬件==完成。装入Cache的是主存中的tag标记部分，以及有效位，可能还有脏位
    + ==直接映射==：
        + 主存块只能装入Cache中唯一位置，==$j=i\ mod \ 2^c$==，冲突时直接替换
        + 空间利用率最低，块冲突率最高
        + ==**物理地址：Tag+cache行号+块内地址=主存块号+块内地址**==
    + ==全相联映射==
        + 采用按内容寻址的相联存储器进行地址映射，==装入Cache任何位置==
        + 灵活，空间利用率高，命中率高；地址变换速度慢，成本高
        + ==**物理地址：Tag+块内地址=主存块号+块内地址**==
    + ==组相联映射==
        + 将Cache分成大小相同组，==组间直接映射，组内全相联映射==，即$j=i\ mod \ Q$，j为Cache组号，i为主存块号，Q为Cache组数
        + ==**物理地址：Tag+组号+块内地址=主存块号+块内地址**==
    + ==**Cache总容量=块数\*(标记列阵大小+一个Cache块数据)=块数\*(Tag+有效位+脏位+替换算法控制位+一个Cache块大小)，脏位只在回写法中有，替换算法控制位和替换算法有关，n路组相联的LRU中一组需要n位，即每块1位**。====**没有块号！！！**==。==一个Cache块大小单位为**B**，其他单位为b==
+ Cache主存块替换算法
    + 只有全相联和组相联需要替换算法
    + 随机算法RAND：随即替换，未遵守程序访问的局部性原理，命中率低
    + 先进先出FIFO：替换最早进入的行，只关心进入顺序，未遵守程序访问的局部性原理
    + 近期最少使用LRU：替换长久未访问过的行，优于FIFO，需要设置计数器，命中时清零，否则加1
    + 最不经常使用LFU：替换访问==次数最少==的行，需要设置计数器，命中时加1
+ Cache写策略
    + 命中：
        + ==全写法==：写命中时写时同时写Cache和主存，替换时无需写入主存。访存次数多。需要在Cache和主存之间加入写缓冲，解决速度不匹配
        + ==写回法==：写命中时只写Cache内容，替换出时写回主存。访存次数少，Cache行需要设置脏位，反映是否被修改过
    + 不命中：
        + ==非写分配法==：只写入主存，配合全写法
        + ==写分配法==：将主存加载到Cache后，写Cache，配合写回法
+ 多级Cache：
    + 多级Cache：L1 Cache离CPU最近

## 虚拟存储器：解决主存容量
+ 将主存辅存地址空间统一编址，具有主存的速度和辅存的容量。操作系统和硬件解决逻辑（虚）地址和物理（实）地址映射，若已装入主存，直接访问主存；若未装入主存，则将辅存的一页或一段调入主存后再访问
    + 页式虚拟存储器：基本单位为页
        + ==虚地址：虚页号+页内地址==
        + 页表：记录虚地址到实地址的变换，即已经由虚存调入主存，虚页号+实页号+装入位，在主存中
        + 过程：主存和虚存划分为同样大小的页。将虚地址分为虚页号和页内地址，将页表基址寄存器与虚页号拼接得到页表项地址，在页表中查到虚页号、实页号、装入位，装入位为1，表示已装入主存，根据实页号+页内地址得到实地址；装入位为0，启动I/O系统从辅存装入主存，修改页表
        + 优缺点：页面长度固定，页表简单，调入方便；程序不是页面整数倍，造成浪费，页没有逻辑独立性，不如段式方便
    + 段式虚拟存储器：基本单位为段
        + ==虚地址：段号+段内地址==
        + 段表：段号+装入位+段起点+段长
        + 过程：按程序逻辑划分为不同长度的段。将段地址分为段号和段内地址，段表基址寄存器和段号拼接为段表行，在段表中查到段号、装入位、段起点、段长。剩余同上
        + 优缺点：段有逻辑独立性，易于编译、管理、保护、修改、共享；段长度可变，易造成浪费
    + 段页式虚拟存储器：基本单位为页
        + ==虚地址：段号+段内页号+页内地址==
        + 段表、页表：每个程序一个段表，每段一个页表
        + 过程：程序按逻辑分段，每段和主存都划分位固定大小的页。同上
        + 优缺点：兼具段式页式优点；需要查两次表，系统开销大
+ 快表TLB：在Cache中保存页表（慢表Page）的某些页的副本，采用相联存储器，根据内容查找地址，速度快。这样就无需访问两次主存（查表、访问主存得到数据）
    + 访存顺序：==TLB->页表（Page慢表）->Cache->主存。用虚拟地址的**虚拟页号**部分查TLB，虚拟页号被分为Tag+组号（组相联）或Tag+行号（直接映射）或Tag（全相联），比较组号、Tag、有效位，若TLB命中，则一定从辅存调入主存，得到的物理块号和之前虚拟地址内的页内偏移拼接为物理地址。若TLB不命中，查页表Page，如果为多级页表，虚拟页号将被分为一级页号和二级页号，根据页目录寄存器中的基址+一级页号\*页表项大小找到二级页表基地址，根据二级页表基地址+二级页号\*页表项大小找到物理块号，如果命中，说明已经从辅存调入主存，更新TLB（，有可能要求再查TLB），物理块号和虚拟地址中的页内偏移拼接为物理地址。如果Page不命中，说明在辅存中，调入主存，更新Page和TLB，重新运行命令。此时TLB必已经命中，根据物理地址查Cache，**整个**物理地址被分为Tag+行号+Cache块内偏移（直接映射）或Tag+组号+Cache块内偏移（组相联）或Tag+Cache块内偏移（全相联），根据组号和Tag和有效位查Cache，命中说明已经在Cache中，根据块内偏移读出数据。Cache未命中，说明在主存中，根据物理块号和页内偏移读出数据，调入Cache（，可能要求再访问Cache）。**默认查TLB和查Page是先后关系、查Cache和查主存是先后关系**==
    + ==**查TLB时，只会用到逻辑地址的虚拟页号部分**==，如组相联TLB中，==**虚地址=虚拟页号+页内偏移=Tag+组号+页内偏移**==。区别用物理地址查Cache，如直接映射Cache中，==**物理地址=物理页号+页内偏移=Tag+行号+cache块内偏移，根据原理可得=主存块号+cache块内偏移**==
    + 若TLB命中，TLB是Page一部分的副本，说明Page必命中；TLB不命中，什么都无法说明
    + 若Cache命中，Cache是主存一部分的副本，说明必已经由虚存调入主存，Page必命中
    + 慢表大小=（实页号位数+有效位+修改位）*虚页号个数
    + 快表大小=（虚页tag位数+实页号位数+有效位+修改位）*快表表项数
+ 置换算法：clock、lru、fifo、opt、改进clock

## 零碎知识点
+ 存储系统效率=顶层单次时间/平均时间=$\frac{1}{H+(1-H)*r}$，其中H为命中率，r为顶层/底层单次时间之比
+ 主存由RAM和ROM构成，其中RAM为DRAM
+ 动态静态RAM都用了MOS
+ 增大带宽方法：单体多字、低位交叉多体并行
+ ==二路组相联：Cache中每组2块==
+ 由于Cache中是副本，Cache对主存容量没有增加
+ 区别地址映射和地址变换
+ 现代Cache分为片载Cache和片外Cache两级，并将指令和数据分开设置
+ Cache对所有程序员透明，由硬件实现映射；虚存只对应用程序员透明，由操作系统（和硬件）实现映射
+ ==虚存不命中，从主存调入虚存的影响>Cache不命中，从主存调入Cache影响==
+ 段式和页式虚拟存储系统最多2次访问主存，段页式最多3次
+ 磁盘一般使用调频制
+ ==组相联Cache块替换题，如LRU==：如Cache4个行，2路组相联，则2组每组2块，列表时候分好组，014589在一组，2367在2组

# MIPS指令系统及汇编语言

## 指令格式
+ 指令字长不一定等于机器字长，但一定要是8的倍数
+ x地址指令：指令中有x个地址码
+ 定长操作码：操作码长度相同
+ 扩展操作码：指令字长不变条件下增加指令种类
    + 以16位指令为例
        + ==16条零地址指令1111 1111 1111 0000-1111 1111 1111 1111==
        + ==15条一地址指令1111 1111 0000 A_3-1111 1111 1110 A_3，1111留作零地址==
        + ==15条二地址指令1111 0000 A_2 A_1-1111 1110 A_2 A_3，1111留作一地址和零地址==
        + ==15条3地址指令0000 A_1 A_2 A_3-1110 A_1 A_2 A_3，1111留作二地址、一地址和零地址==
+ 指令=操作码+地址码

## 寻址方式
+ 指令寻址：寻找下一条跳指令地址
    + 顺序寻址：PC+1
    + 跳跃寻址：修改PC值
+ 数据寻址：寻找操作数真实地址EA，设指令为操作码+寻址特征+形式地址A。==(X)代表地址为X的数值，X可以是寄存器或内存==
    + ==隐含寻址==：通常隐含的数在累加器ACC中
    + ==立即寻址==：存放立即数本身而不是操作数地址
    + ==直接寻址==：形式地址A存放A的真实地址EA，EA=A，寻址范围为$2^{A的位数}$
    + ==间接寻址==：形式地址A是有效地址所在存储单元的地址，即操作数地址的地址,EA=(A)，寻址范围为$2^{存储字长}$
    + ==寄存器寻址==：形式地址A是是操作数所在的寄存器编号,EA=R
    + ==寄存器间接寻址==：形式地址A是寄存器编号，寄存器存储的是操作数所在主存单元地址,EA=(R)
    + ==相对寻址==：有效地址EA===下==一条指令在程序计数器PC中的地址+形式地址A,==EA=(PC)+1+A==，寻址范围为$2^{A的位数}$
    + ==基址寻址==：有效地址EA=基址寄存器BR+形式地址A，面向OS，处理==多道程序==,EA=(BR)+A，注意以==基址寄存器值为基址，A为偏移量==，寻址范围为$2^{A的位数}$
    + ==变址寻址==：有效地址EA=变址寄存器IX+形式地址A，面向用户，处理==数组==,EA=(IX)+A，注意是以==A为基址，变址寄存器值为偏移量==，因此寻址范围为$2^{变址寄存器位数}$
    + 堆栈寻址：
        + 硬堆栈：寄存器堆栈
        + 软堆栈：主存堆栈

## CISC和RISC
+ 复杂指令系统计算机==CISC==（Complex Instruction Set Computer）：如x86
    + ==大多使用流水线==
    + ==指令字长不固定，种类多，功能强，寻址方式多==
    + ==大多采用微程序==
+ 精简指令系统计算机==RISC==(Reduced Instruction Set Computer)：如mips、arm
    + ==一定采用流水线==
    + ==CPU的通用寄存器多==
    + ==指令长度固定，种类少，简短，寻址方式少==
    + ==很少使用微程序==
    + 大多指令在一个时钟周期内完成，==按边界对齐==

## MIPS指令系统
+ MIPS指令：没有间接寻址
    + 3种类型的==32位==定长指令：
        + ==R类==：两个寄存器操作数计算，结果送寄存器，如add,
        + ==I类==：==1个16位立即数==，结果送寄存器。如Load/Store,addi
        + ==J类==：跳转指令，26位跳转地址
            + Load/Store：寻址方式为寄存器+偏移
                + ==I型==：LW，LB
            + 运算指令：
                + I型：ADDI，XORI
                + R型：ADD，XOR，SLL，SLLV
            + 跳转指令：
                + J型：J，JAL    
                + ==R型：JALR，JR==
            + 转移指令：使用相对寻址
                + ==I型：BEQ==
            + SYSCALL：系统调用
+ 寄存器：32个32位寄存器
    + $ra：返回地址
    + $a：参数
    + $v：返回值
+ 内存：32bit=4bytes，即每次递增4，==数组下标要乘4==
+ ==目的寄存器为Rt（I型）或Rd（R型）==

## 零碎知识点
+ 现代计算机都采用字节编址，即一个内存单元只能存放一个字节的信息
+ 由于Intel的占有率，CISC比重大，单纯RISC无法兼容老机器。现代已经融合两者
+ 浮动指哪个进程在最前面的变化，相对寻址利于浮动
+ JAL：jump and link
+ JALR：jump and link register
+ ==没有subi，subiu，立即数减法用加法实现==
+ ==带U的是不检查溢出，并非无符号运算==
+ 位扩展即符号扩展
+ ==条件转移指令所依据的条件来自程序状态字寄存器PSWR==
+ ==将半字长立即数直接存到寄存器：ori；将一个字长的立即数直接存到寄存器：lui+ori，将一字长立即数代表的内存存入寄存器：lui+lw（偏移低半字）==

# 处理器

## CPU功能和基本结构
+ CPU=运算器+控制器
+ 功能
    + 指令控制
    + 操作控制
    + 时间控制
    + 数据加工
    + 中断处理

## 指令执行过程
+ ==指令周期：每取出**并执行**一条指令的全部时间==，包含多个机器周期（CPU周期），每个机器周期包含多个时钟周期。一个机器周期长度、一个指令周期长度都可能不同。包括取指周期FE、间址周期IND（找操作数地址）、执行周期EX、中断周期INT，但并不是每条指令都有全部四个周期
    + ==取指周期FE==
    + ==间址周期IND==：用于间接寻址
    + ==执行周期EX==
    + ==中断周期INT==
+ 若指令字长是存储字长n倍，则取值周期为n各机器周期

## 数据通路
+ 数据在功能部件之间传送的路径。这里的总线指CPU的内部总线，而不是计算机连接CPU、内存等的总线。
    + ==单总线方式==：寄存器输入输出连在一条公共通路，同一时钟内只能传一条数据
    + ==三总线方式==：寄存器输入输出连在三条公共通路
    + ==专用数据通路方式==：不使用共享总线，性能高，硬件量大
+ 微操作序列

## 控制器功能和原理
+ ==硬布线控制器==（组合逻辑控制器）
    + ==控制信号==：由组合电路根据指令码、状态和时序==即时产生==
    + 特点：执行速度快，但扩充性差，时序系统复杂，适用于==RISC==
+ ==微程序控制器==
    + ==控制信号==：==微程序存储在控制存储器==中，==执行时读出==即可
        + ==微命令==：控制部件向执行部件发出的各种控制命令，==和微操作一一对应==。分相容性和互斥性
        + ==微指令：微命令的集合==，包括微操作码字段和微地址码字段，==一条微指令存放在控制存储器的一个存储单元==
        + ==微程序：微指令的集合，一条机器指令由一段微程序实现。**n种机器指令至少有n+1种微程序，其中1个是公共取指微程序**==
        + 存储控制器：在CPU中，由ROM实现，存放微程序
        + 微指令计数器：决定微指令执行顺序
    + 微指令格式：
        + ==**水平型**==：1位对应1个控制信号，==一条微指令可以定义多个基本操作==。微指令较长，编写繁琐，但构成的微程序较短，速度快
            + ==**直接编码**==：==每个控制信号1位==，微指令长，但==无需译码==
            + ==**字段直接编码**==：==互斥性微指令放在1个字段，相容性微指令在不同字段==，微指令短，需要译码
        + ==**垂直型**==：类似于机器指令，==有操作码，一个微指令只能对应一个基本操作==。微指令较短，易于编写，但构成的微程序较长，速度慢
    + 执行过程：
        + 执行取微指令公共操作
        + 由 ==**机器指令**的**操作码**字段的得到微程序入口地址== ，执行
    + 特点：灵活，时序系统简单，但速度慢，适用于==CISC==

## 指令流水线
+ 原理：时间并行性
+ 每个功能段部件后面都有一个锁存器（缓冲寄存器），保存本流水段执行结果，供给下一流水段使用
+ 性能指标：
    + 吞吐率：单位时间内流水线完成任务数量$TP=\frac{n}{T_k}=\frac{n}{(n+k-1)\Delta T}$
    + ==加速比：同样一批任务，**不用**流水线和**使用**流水线时间之比==$S=\frac{T_0}{T_k}=\frac{kn\Delta T}{(n+k-1)\Delta T}$
    + 效率：设备利用率$E=\frac{T_0}{kT_k}$，一般由时空图数出
+ 冲突：==没有转发时在译码ID阶段**以前**就停下==，即在ID被阻塞，否则ID拿到的寄存器值已经出错
+ ==超标量流水线技术：并行执行多条==，不调整顺序，通过编译优化，将可并行执行的指令搭配，在多条流水线上执行，即以空间换时间
+ ==超流水线技术：时钟周期再分段==，不调整顺序，通过编译优化，一个时钟周期内一个部件使用多次
+ ==超长指令字：多条能并行操作的指令组合成一条超长指令字==

## MIPS处理器
+ ==单周期==：==串行==执行，==每个指令一个时钟周期，时钟周期=执行时间最长的指令的执行时间==
+ ==多周期==：==串行==执行，==每个阶段一个时钟周期，各个指令的时钟周期数不必相同==
+ ==流水线==：==并行==执行，每个阶段一个时钟周期
    + 五部分，每部分之间有控制信号流水线寄存器
        + IF：取指
        + IF/ID级流水线寄存器
        + ID：指令译码
        + ID/EX级流水线寄存器
        + EX：执行
        + EX/MEM级流水线寄存器
        + MEM：内存
        + MEM/WB级流水线寄存器
        + WB：写回
    + 冒险
        + 结构冒险：
            + 取指和访存时争夺内存，指令内存和数据内存分开
            + 读寄存器RF和写寄存器时冲突，但读写非常快，实际上无冲突
        + 数据冒险：
            + ==ADD引起：**2个暂停 或 转发 或 改变顺序**==。有先写后读，译码ID等待上一条写回WB结束才能开始。使用数据转发，由上一条EX直接转发到下一条EX，就无需阻塞
            + ==LOAD引起：**2个暂停 或 1个暂停+转发 或 改变顺序**，且不能在MEM转发==。lw指令在MEM/WB才能产生结果，转发到EX/MEM会大幅增加CPU时钟频率。故使用延迟槽，在lw进入ID/EX后，冻结IF/ID，清零ID/EX，禁止PC，相当于插入nop。当lw在MEM/WB后，转发到EX
        + ==控制冒险==：
            + beq指令引起：==**3个暂停 或 分支比较前移到ID+1暂停**==
            + j指令引起
    + 实现转发和暂停：
        + $T_{new}>T_{use}$：结果产生的比被使用时晚，必须暂停
        + $T_{new}\le T_{use}\ or\ (T_{new}=0\ and\ not\ in\ MEM/WB)$：转发

## 零碎知识点
+ PSW程序状态字寄存器属于运算器
+ PC位数和存储单元个数（存储器容量）有关，因为PC存的是指令在主存中的地址
+ IR位数和指令字长有关
+ 通用寄存器位数与机器字长有关
+ 指令译码器只对指令的操作码译码
+ 存储器数据寄存器MDR、存储器地址寄存器MAR在cpu里，但属于存储器
+ ==一地址指令直接寻址，访问2次存储器（取指+取操作数）==
+ 程序控制指令：条件转移、无条件转移、子程序调用、中断。其形式地址不是操作数地址，而是下一条指令地址
+ 三态门可以实现将内存设置为读、写和高阻态（不读不写），控制连接与断开，==连接到总线的设备必须有三态门控制==
+ 隐指令：指令系统中没有的指令
+ 取指是控制器固有功能，不受指令控制，但在微程序控制方式下，需要1个公共取指微程序控制
+ RAW指Read After Write写后读，可能产生冲突。WAW和WAR不会有冲突
+ 指令ADD R1,R2,R3中第一个操作数是目的操作数
+ 数据相关对流水线影响最严重
+ JAL后使用延迟槽nop，$31存放PC+8

# 总线
+ 总线是能为多个部件==分时共享==的公共信息传送路线
    + ==分时：同一时刻只能有1个部件向总线发送信息==
    + ==共享：多个部件可以同时接收相同信息==
    + 分类
        + 片内总线：CPU内部的寄存器、ALU等之间
        + 系统总线：计算机系统内部的CPU、主存、IO等之间
            + 数据总线：和存储字长有关，==取指周期的指令、操作数、中断类型号、间接寻址第一次访存得到的地址==
            + 地址总线：和主存地址空间大小，==只能由CPU传向内存或IO端口==
            + 控制总线：传输控制信号、响应信号和时序信号，==握手应答信号==
        + 通信总线（外部总线）：计算机系统之间
+ 主设备：获得总线控制权的设备
+ 从设备：只能响应总线命令
+ ==靠近CPU的总线较快==
+ 总线结构
    + 单总线：只有系统总线，包括数据、地址、控制总线，但不是只有一根信号线
    + 双总线：主存总线+I/O总线
    + ==三总线：主存总线+I/O总线+DMA总线==。DMA总线用于在内存和高速外设之间传送数据
+ 总线性能指标
    + 总线周期
    + 时钟频率：总线时钟周期的倒数
    + 工作频率：时钟频率/N，1总线周期=N时钟周期
    + 总线带宽：数据传输率，=总线宽度\*总线工作频率=总线宽度\*时钟频率/N
+ ==猝发传输（突发传输）：一次传送一个首地址和一批连续的数据==，可以提高带宽

## 总线仲裁
+ 解决多个主设备同时竞争总线控制权问题
+ ==集中仲裁==：总线控制逻辑集中于1个设备中（如CPU），==由获得总线控制权的设备发送总线忙信号==
    + ==**链式查询**==：设备向总线控制器发出“总线请求”，若允许，总线控制器向该设备发出“总线允许”，设备发出“总线忙”。==越靠近总线控制器优先级越高==，优先级固定，结构简单，==对电路故障敏感==。需要3根线（==1总线请求、1总线允许、1总线忙==）
    + ==**计数器定时查询**==：==优先级可变==。需要$\log_2n$向上取整+2根线（==1总线请求、1总线忙、$\log_2n$向上取整个设备地址==），无需允许线
    + ==**独立请求**==：==优先级可变，速度快==。需要2n+1根线（==n总线请求，n总线允许，1总线忙==）
+ 分布仲裁

## 总线定时
+ 总线在双方交换数据过程中需要时间上配合关系的控制
    + 同步：采用==统一时钟信号==。传送速度快，主从设备强制性同步，不能及时校验有效性。适合短距离和主从设备存取时间接近
    + 异步：通过==握手信号==实现定时控制，速度慢，适合主从设备速度相差大时
        + ==不互锁：主设备不必等到从设备回答就可撤销请求信号==
        + ==半互锁：主设备等到从设备回答后，才能撤销请求信号。从设备不必等到主设备撤销请求，即可撤销回答==
        + ==全互锁：主设备等到从设备回答后，才能撤销请求信号，从设备等到主设备撤销请求，才能撤销回答==，==最慢==
    + 半同步：增设一条“等待”信号线，既采用时钟信号又采用握手信号
+ 总线传输四个阶段
    + 申请分配
        + 请求
        + 仲裁
    + 寻址
    + 传输
    + 结束

## 总线标准
+ ==PCI==：高带宽的局部总线，和CPU时钟频率无关，支持即插即用和热插拔，==并行==总线
+ ==ISA==：==系统总线==，并行总线
+ ==USB==：支持即插即用和热插拔，==串行总线，一次传1位数据==
+ ==PCIExpress（PCIE）==：==串行==
+ ==EISA、VESA、AGP、RS-232C、PCMCIA、IDE、SCSI、SATA==

## 零碎知识点
+ CPU通过周期区分数据和指令，主存通过==总线类型==区分数据和地址
+ 计数器定时查询设置从上一次终点开始计数，优先级相同。固定从某个数开始，优先级递减

# I/O系统
I/O设备通过==I/O接口==与总线相连，通过==设备控制器==控制I/O设备具体动作并连接主板

## 外部设备
+ 输入设备：采用中断原理
    + 键盘
    + 鼠标：机械式、光电式
+ 输出设备：
    + 显示器：
        + 刷新频率：单位时间内扫描整个屏幕内容次数
        + 显示存储器（刷新存储器）VRAM：存放ascii码
            + VRAM容量=分辨率\*灰度级
            + VRAM带宽=分辨率\*灰度级\*帧频
    + 打印机：
        + 按工作原理分类
            + ==击打式==
            + ==非击打式==
        + 按工作方式分类
            + 点阵打印机
            + 针式打印机
            + 喷墨式打印机
            + 激光打印机
        + ==按能否打出汉字==
            + ==点阵式==
            + ==活字式：能打出汉字==
+ 辅助存储器
    + 磁盘存储器
        ![磁盘](https://i.loli.net/2019/10/07/BW62sVXaMrugczw.png)
        + 组成
            + 磁盘驱动器
            + 磁盘控制器
            + 盘面
                + 磁头数：硬盘的记录面数
                + 柱面数：一个记录面上的磁道数
                + 扇区数：一个磁道上的扇区数
        + 磁记录原理：磁头和磁性记录介质相对运动时，通过电磁转换完成读写操作
        + 磁记录方式：==调频制==FM和改进型调频制MFM
        + 性能：
            + 容量
            + 记录密度
            + 平均读取时间=寻道时间（找到磁道，即磁头在半径方向上走1/2半径长度的时间）+找到扇区时间（即旋转半周的时间）+传输时间（即扇区大小/传输速率，或旋转1周时间/每个磁道扇区数）
            + 数据传输率D=磁盘转数r*每磁道容量N
            + 位密度：在一个磁道周长上的数据量/周长，越靠近中心位密度越大
            + 磁道密度：半径方向上磁道数/（外环长度-内环长度）
        + 磁盘地址：驱动器号+柱面号（磁道号）+盘面号+扇区号
    + 磁盘列阵RAID：多个独立物理磁盘组成一个独立的逻辑盘，并行访问
        + ==RAID0：无冗余无校验，1块硬盘即可==
        + ==RAID1：镜像磁盘列阵，两磁盘互为备份，容量减半，至少2块硬盘==
        + RAID2：使用纠错海明码
        + ==RAID3：位交叉奇偶校验，奇偶校验位交叉分布在一台专用磁盘中，至少3块硬盘==
        + ==RAID4：块交叉奇偶校验，奇偶校验位交叉分布在一台专用磁盘中，至少3块硬盘==
        + ==RAID5：奇偶校验，奇偶校验位交叉分布在**各个磁盘中**，至少3块硬盘==
    + 光盘存储器：
        + ==CD-ROM==：只读型光盘
        + CD-R：只可写入一次
        + CD-RW：可读可写
        + DVD-ROM：高容量CD-ROM
    + 固态硬盘：采用Flash Memory

## I/O接口
+ I/O接口：主机和外设之间的交接界面
+ 功能：
    + 选址
    + 命令传送
    + 数据传送
    + 反映外设状态
+ 内部接口：与系统总线相连，并行传输。信号线有数据线（双向），地址线（总线到I/O接口），控制线（总线到I/O接口）
+ 外部接口：与外设相连，可并可串
+ IO指令控制的数据传输是==通用寄存器和IO端口之间==
+ ==端口：接口中的寄存器==
    + 分类
        + 数据端口：可读可写
        + 状态端口：只读
        + 控制端口：只写
    + 编址：
        + ==统一编址==（寄存器映射方式）：==把端口当作存储器单元编址。无需专门I/O指令==，编制空间大，但计算机内存容量变小，速度慢。==如mips==
        + ==独立编址==（I/O映射方式）：和存储器地址无关，有独立io地址和存储器地址，设置专门输入输出指令

## I/O控制方式
+ ==**程序查询方式**==：CPU查询和等待I/O设备，串行，效率低
+ ==**程序中断方式**==：外设向CPU发出中断请求，响应后执行中断服务程序。CPU和外设并行，传送和主程序串行，在==指令执行周期之后的**中断周期处理中断**==
    + 分类：
        + 内中断和外中断
        + 硬件中断和软件中断
        + 非屏蔽中断和可屏蔽中断：都是硬件中断
    + 中断判优：由硬件排队器或软件排队器实现。==故障中断>软件中断，非屏蔽中断>可屏蔽中断，**DMA请求>I/O设备中断**，高速设备>低速设备，输入设备>输出设备，实时设备>普通设备，重新启动优先级很低，**访管（自陷）>程序性>I/O**==
    + CPU响应中断条件：中断源有中断请求、CPU允许中断及开中断、一条指令执行完毕，没有更紧迫任务
    + 中断隐指令：由硬件实现，不是真正指令，没有操作码，是CPU转去执行中断的操作。包括：关中断，保存断点，引出中断服务程序
    + ==中断向量：设备各自的中断服务程序的入口地址==。存放在中断向量表。==中断向量的地址是中断程序入口地址的地址==。通过==硬件向量法和软件查询法==找到中断向量
    + 中断处理过程：
        + ==**关中断、保存断点（PC保存在堆栈中）、引出中断服务程序、保存现场和屏蔽字（即保存通用寄存器）、执行中断处理事件（包括开中断、执行中断服务程序、关中断）、恢复现场和屏蔽字、开中断、中断返回**==
        + ==**前三步（即执行中断隐指令）为硬件，后面为软件**==
        + 单级中断和多级中断的前三步相同
    + ==多重中断屏蔽字：在中断源A处于中断中，若B可以申请中断则为0，B的申请被屏蔽则为1==
+ DMA方式：==主存和外设==之间直接传输，==完全由**硬件**控制==，适用于==高速设备大批量==传送数据（键盘鼠标不行），硬件开销大，不经过CPU，速度快，无需保护恢复CPU现场，但需要控制总线。CPU和外设并行，传送和主程序并行，==在任何一个机器周期**结束**即（如取指结束，间址结束，执行结束，中断结束）可处理DMA请求，在机器**周期中不可响应**==
    + I/O设备和CPU在访问主存时冲突：
        + 停止CPU访问主存
        + DMA和CPU交替访存
        + ==周期挪用（周期窃取）：挪用**存储**周期==
    + 传送过程：
        + ==预处理==：==**外设**向DMA控制器发送DMA请求==，==DMA向CPU==发送 ==**总线**控制请求==，==**DMA控制器**控制总线==
        + ==数据传送==：只由DMA控制器实现，不使用CPU
        + ==后处理==：==DMA向CPU发送中断请求==，CPU做DMA结束处理
    + ==DMA和内存之间的“直接数据通路”并不是一条真实的物理通路==
+ 通道方式：由==访管指令（自陷）进入内核态==的管道程序，启动管道，==由**硬件**控制。通道程序放在主存中，**通道控制内存位置、数据块大小等信息（DMA是由CPU控制），可以同时和多个设备交换数据**==

## 零碎知识点
+ I/O端口为寄存器，端口+控制逻辑=接口
+ ascii码7b
+ 未格式化的硬盘容量大于格式化后的实际容量
+ 磁盘驱动器向磁片记录数据时采用串行方式
+ 浮点数下溢不需要中断；cache是存储设备，不能作为中断源
+ ==自陷不是异常，是人为设定的特定处理事件==
+ ==DMA和程序中断都有中断，但作用不同，程序中断的中断请求是为了传送数据，DMA是为了报告传送结束==
+ CPU响应中断主要保存的是PC和PSW
+ 中断标志触发器指示CPU是否进入中断周期，允许中断触发器表示开放或关闭终端系统 
+ 通道是具有特殊功能的处理器，由I/O指令启动，执行通道指令

# ==大题==
+ RAM、ROM选片问题
    + 已知主存数据线8位，地址线20位，系统区域ROM为256KB，其余为用户区域。现有若干64K\*8b的ROM和256K\*8b的DRAM
    + 问DRAM管脚：256K=$2^{18}$，由于行列应选相差不大且行尽量少的（按行刷新，行少时刷新开销小），本来行地址线和列地址线都为9根，由于DRAM采用地址复用，则行列地址线共9根，译码器输出的行或列选择线各 ==$2^9$根==，即512行\*512列。刷新计数器即行地址线个数9，每次刷新数据大小=每列长度\*数据=$2^9*8b$
    + 问DRAM刷新
        + 集中：假设存取周期为0.5μs，已知512行，可求出刷新的死时间0.5μs\*512
        + 分散：假设存取周期为0.5μs，延长一倍为1μs，刷新周期1μs\*512
        + 异步（分散集中相结合）：2ms内对512行刷新，每行2ms/512，刷新周期2ms/512
    + 问每个芯片地址空间范围（十六进制）：和数据线无关，只看地址线，写成16的n次方形式
+ 什么是存储程序？
    + 将指令以代码形式实现输入计算机主存，按其在存储器中首地址执行第一条指令，此后按规定顺序依次顺序执行其他指令，直到程序执行结束
+ 指令扩展题
    + 已知指令字长16位，地址码6位，指令有零地址、一地址、二地址，若采用扩展操作码技术，已有二地址P条，零地址Q条，则最多有多少一地址？
    + 设一地址R条，二地址中操作数16-6-6=4位，$2^4-P$即为二地址中前4位中没有用到的操作码组合数，一地址时又多出6位作为操作码，则一地址共$(2^4-P)*2^6$个，零地址即为$((2^4-P)*2^6-R)*2^6=Q$，解得R
+ 微操作题
    + 如ADD R1,(R2)，即R1为寄存器寻址，R2为寄存器间接寻址，目的寄存器为R1，(R1)+((R2))->R1，ALU有一个操作数寄存器A，一个结果寄存器AC。（如果为ADD (R1),R2，则目的地址为R1值代表的内存地址）
    + 取指
        + (PC)->MAR PCout,MARin
        + M(MAR)->MDR MARout,MemR,MDRin
        + (PC)+1->PC +1
        + MDR->IR MDRout,IRin
        + 指令译码
    + 间址
        + (R2)->MAR R2out,MARin
        + M(MAR)->MDR MARout,MemR,MDRin
        + MDR->A MDRout,Ain
    + 执行
        + (R1)+(A)->AC R1out,ALUin,+
        + (AC)->R1 ACout,R1in
+ DMA和中断区别
    + DMA仅在预处理和后处理使用CPU
    + DMA发生在每个机器周期结束时
    + DMA传送过程不需要CPU干预
    + DMA请求优先级高于中断
    + DMA靠硬件传送
+ 通道和DMA区别
    + DMA需要CPU控制传输数据块大小、内存位置等，通道由通道控制这些信息
    + DMA控制器只能对应一台设备，通道可以控制多台设备