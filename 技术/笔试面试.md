# [Leetcode](https://leetcode-cn.com)

+ 刷题网站[Leetcode](https://leetcode-cn.com)：只需完成最火100题和面试高频100题
+ 题解网站[leetcode题解](https://github.com/azl397985856/leetcode)
+ 可视化网站[LeetCodeAnimation](https://link.zhihu.com/?target=https%3A//github.com/MisterBooo/LeetCodeAnimation)
+ 面试难度在LeetCode的中等难度水平，应达到20分钟一题

## [Top 100 Liked Questions](https://leetcode-cn.com/problemset/hot-100/)

### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

+ 题目：在list中找到两个数，满足其和为target。难点为降低时间复杂度。

+ 思路

  + 暴力法较慢，$O(n^2)$时间复杂度。
  + **哈希（字典）**，边存边遍历，注意`twoSum([3,3], 6)`测试点，$O(n)$时间复杂度。
  
+ 题解

  ```python
  class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
          nums_index = {}  # 存储num第一次出现的index，防止twoSum([3,3], 6)的测试点
          for i, num in enumerate(nums):  # 边存边遍历
              j = nums_index.get(target - num)
              if j != None:
                  return [j, i]
              nums_index[num] = i
  ```

+ 知识点
  + 拷贝
    + 赋值：`list2 = list1`，即别名，变一个list的元素时另一list也会**改变**。
    + 浅拷贝：`list2 = list1.copy()`，变一个list的元素时另一list**不变**，变一个list的元素中的元素（子元素）时另一list**改变**。
    + 深拷贝：`list2 = copy.deepcopy(list1)`，变一个list的元素时另一list**不变**，完全独立。
  + 同时遍历list的index和value：`for index, value in enumerate(list)`。
  + python字典用哈希实现，对于哈希，一般复杂度为$O(1)$，最差情况全部哈希为一样的值，复杂度为$O(n)$。
  + 边遍历list边删除：从后向前遍历即可。

### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

+ 题目：将链表各项相加，注意进位。难点为考虑进位。

+ 思路：逐位相加，注意`(2) + (8)`测试点。

+ 题解

  ```python
  # Definition for singly-linked list.
  # class ListNode:
  #     def __init__(self, x):
  #         self.val = x
  #         self.next = None
  
  class Solution:
      def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
          carried = 0  # 进位
          head = ListNode(0)
          last = head
          while l1 or l2:
              temp = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carried 
              last.next = ListNode(temp % 10)
              last = last.next
              carried = temp // 10
              if l1:
                  l1 = l1.next
              if l2:
                  l2 = l2.next
          if carried:
              last.next = ListNode(carried)
          return head.next
  ```

+ 知识点
  + python中简写`if a != None`或`if a != 0`为`if a`。
  + python中没有c语言的三目表达式，应写成`a = b if b > c else c`。

### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

+ 题目：找到一个字符串内的最长字串，满足字串内没有重复的字母。难点为降低时间复杂度。

+ 思路

  + 暴力法，找到以每个`string[index]`开头的满足条件子串，$O(n^2)$时间复杂度。
  + ==**滑动窗口**==，即在字符串中维护一个满足条件的窗口`string[left, right]`，查找时用哈希表（字典），$O(n)$时间复杂度。
  
+ 题解

  ```python
  class DistinctSubstring:
      def longestSubstring(self, A, n):
          # write code here
          s = A
          left, right = 0, -1  # 滑动窗口
          max_len = 0
          dic = {}  # 记录字母上次出现位置
          for i in range(n):
              char = s[i]
              if char not in dic.keys() or dic[char] < left:
                  right += 1
                  if right - left + 1 > max_len:
                      max_len = right - left + 1
              else:
                  left = dic[char] + 1
                  right += 1
              dic[char] = i
          return max_len
  ```

### [4. 寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

+ 题目：给两个各自有序的list，找到合并后list的中位数。难点为要求$O(\log(m+n))$时间复杂度。

+ 思路

  + 合并两个list，每次从首位各pop一个元素。$O(m+n)$时间复杂度，不符合。

  + ==**二分查找**==：看到复杂度为$\log$，显然需要二分思想。题目变为在$O(\log(m+n))$时间复杂度内找第k小的数。
  + 首先保证`nums1`短于`nums2`，此时找第`k`小的数，只需判断`nums1[k/2]`和`nums2[k/2]`谁更小，若前者更小，则`nums1[:k/2+1]`的`x`个数一定小于总数组第`k`小个数，将这一部分移除，只需找到剩余数组的第`k-x`小的数。直到需要找到剩余部分第一小的数，比较两数组首元素即可。

+ 题解

  ```python
  def minKth(nums1: List[int], start1: int, end1: int, nums2: List[int], start2: int, end2: int, k: int) -> int:  # 求第k小的数
      while 1:
          if end1 - start1 > end2 - start2:  # 保证nums1最短
              return minKth(nums2, start2, end2, nums1, start1, end1 ,k)
          if end1 - start1 < 0:  # 在nums1最短前提下，nums2不可能先于nums1空掉，则只有可能nums1为空
              return nums2[start2 + k - 1]
          if k == 1:
              return min(nums1[start1], nums2[start2])  # 要找第1小的数时，只需要比较nums1和nums2第一个数
          i = start1 + min(end1 - start1 + 1, k // 2) - 1
          j = start2 + min(end2 - start2 + 1, k // 2) - 1
          if nums1[i] <= nums2[j]:  # start1到i的数一定小于总数组第k小的数，移走x个数，此后只需要找剩余数组里第k-x小的数
              k -= i - start1 + 1
              start1 = i + 1
          else:
              k -= j - start2 + 1
              start2 = j + 1
  
  class Solution:
      def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
          if len(nums1) > len(nums2):  # 保证nums1最短
              nums1, nums2 = nums2, nums1
          m, n = len(nums1), len(nums2)
          left = (m + n + 1) // 2  # 对于m+n为奇数，第left小和第right小的数是一个数
          right = (m + n + 2) // 2
          return (minKth(nums1, 0, m - 1, nums2, 0, n - 1, left) + minKth(nums1, 0, m - 1, nums2, 0, n - 1, right)) / 2
  ```


### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

+ 题目：找到一个string内的最长回文子串。

+ 思路

  + ==**动态规划**==，状态转移方程$dp\{i,j\}=\begin{cases}true&&dp\{i+1,j-1\}\ is\ true\ and\ s[i]==s[j]\\false&& other\end{cases}$，即`dp{i,j}=(s[i]==s[j]) and dp{i+1,j-1}`，$O(n^2)$时间复杂度。显然`j>=i`，故`dp`矩阵为上三角矩阵，且`dp{i+1,j-1}`在`dp{i,j}`左下方向，故遍历时从右下往左上遍历，即外`i--`内`j++`。
  + 中心扩展法，根据回文中心遍历，注意回文中心可能为`abcba`的`c`，也可能为`abba`的`bb`，$O(n^2)$时间复杂度。

+ 题解

  ```python
  class Solution:  # 动态规划
      def longestPalindrome(self, s: str) -> str:
          length = len(s)
          if length < 2:
              return s
  
          res = ""
          dp = [[False] * length for i in range(length)]
          for i in range(length):
              if i < length - 1 and s[i] == s[i + 1]:
                  dp[i][i + 1] = True
              dp[i][i] = True
          for i in range(length - 1, -1, -1):
              for j in range(i, length):
                  if i < length - 1 and j > 0 and i + 1 <= j - 1:
                      dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
                  if dp[i][j] and j - i + 1 > len(res):
                      res = s[i : j + 1]
          return res
  
  
  class Solution:  # 中心扩展法
      def longestPalindrome(self, s: str) -> str:
          length = len(s)
          if length < 2:
              return s
  		
          res = ""
          for index in range(length):
              for bias in range(min(index + 1, length - index)):
                  if s[index - bias] == s[index + bias]:
                      if bias + bias + 1 > len(res):
                          res = s[index - bias : index + bias + 1]
                  else:
                      break
              if index != length - 1:
                  for bias in range(min(index + 1, length - index - 1)):
                      if s[index - bias] == s[index + 1 + bias]:
                          if bias + bias + 2 > len(res):
                              res = s[index - bias : index + bias + 2]
                      else:
                          break
          return res
  ```

+ 知识点

  + 初始化二维数组`[[0] * 5 for i in range(5)]`或`[[0 for i in range(5)] for i in range(5)]`。

### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)



## [Top Interview Questions](https://leetcode-cn.com/problemset/top/)

## 未分类

### 拓扑排序：[296.火星词典](https://leetcode-cn.com/problems/alien-dictionary/comments/)

+ 对于一个图，满足每个节点只出现一次，A节点在B节点前则只有A到B的边没有B到A的边，则符合拓扑排序。输出时每次选一个入度为0的节点开始输出，删除该节点，其连接的节点入度-1。

### 进制转换[660.移除9](https://leetcode-cn.com/problems/remove-9/solution/yi-chu-9-by-leetcode/)

+ 删除所有带9的数字，求第n个。写出以后发现即求n的9进制数。

# 剑指offer、牛客网算法课

+ [直通BAT面试算法精讲课](https://www.nowcoder.com/study/vod/1)：实际为剑指offer的讲解版，题目基本涵盖剑指offer题目，但讲解不细，基本为串讲，有对应在线练习题，不讲解正确代码，==思路讲解的很辣鸡==。难度有，适合科班学过，准备面试用。牛客网编译器不支持`print`，报错不给行号。
+ [剑指offer](https://www.nowcoder.com/ta/coding-interviews?page=1)：《剑指offer》题目的电子版。

## 查找

### 找局部最小

+ 题目：数组中相邻数不相等，找到一个局部最小值的下标。局部最小值定义为左右长度1范围内，该数最小。找到任意一个局部最小即可。
+ 思路：二分搜索，$O(\log(n))$时间复杂度。

### 找元素出现的最左侧位置

+ 思路：二分搜索，$O(\log(n))$时间复杂度。

+ 题解

  ```python
  class LeftMostAppearance:
      def findPos(self, arr, n, num):
          # write code here
          if not arr:
              return -1
          left, right = 0, n - 1
          res = -1
          while left <= right:
              mid = (left + right) // 2
              if arr[mid] == num:
                  res = mid
                  right = mid - 1
              elif arr[mid] > num:
                  right = mid - 1
              else:
                  left = mid + 1
          return res
  ```

### 求完全二叉树节点个数

+ 思路：二分搜索，先求层数。再从头节点开始，找右子树的最左节点，证明左子树是否为满二叉树。

### 求N的k次方

+ 思路：二分，将k变为二进制，每一位就是1、2、4、8，求解N的m次方时，只需$N^m=N^{m-1}*N^{m-1}$，$O(\log(n))$时间复杂度。

+ 题解

  ```python
  class QuickPower:
      def getPower(self, k, N):
          # write code here
          binary = []
          res = []
          start = 0
          while N != 0:
              binary.append(N % 2)
              N //= 2
              if start == 0:
                  res.append(k)
              else:
                  res.append(res[-1] * res[-1] % 1000000007)  # 注意是乘号，且要存之前就取余
              start = 1
          value = 1
          for i in range(len(binary)):
              if binary[i]:
                  value = res[i] * value % 1000000007
          return value
  ```

### 找一个旋转数组的最小值

+ 题目：旋转数组指将升序数组前n个移到后面，如3，4，5，1，2。

+ 思路：二分查找，中间值和左右边界值判断大小。特例：相等时，如1，1，1，0，1和1，0，1，1，1无法判断，需要顺序查找。

+ 题解

  ```python
  class Solution:
      def minNumberInRotateArray(self, rotateArray):
          # write code here
          if not rotateArray:
              return None
          
          left = 0
          right = len(rotateArray) - 1
          if rotateArray[left] < rotateArray[right]:
              return rotateArray[0]
          
          while 1:
              mid = (left + right) // 2
              if rotateArray[mid] < rotateArray[left]:
                  right = mid
                  left += 1
              elif rotateArray[mid] > rotateArray[right]:
                  left = mid + 1
              else:  # 顺序查找
                  for i in range(left, right - 1):
                      if rotateArray[i] > rotateArray[i + 1]:
                          return rotateArray[i + 1]
                  break
          return rotateArray[left]  # 如[1, 1]测试点
  ```

## 排序

### 冒泡排序

+ 思路：第一个和第二个比较，大者放在后面，再二三比较。一轮下来，最大的数排在了最后，此时只需排序前n-1个。**$O(n^2)$时间复杂度，稳定（由于两个3一样大时，不会向后冒泡）。**

+ 题解

  ```python
  class BubbleSort:
      def bubbleSort(self, A, n):
          # write code here
          for i in range(n):
              for j in range(n - i - 1):
                  if A[j] > A[j+1]:
                      A[j], A[j+1] = A[j+1], A[j]
          return A
  ```

### 选择排序

+ 思路：在前n个数里选择最大的，放在最后，再将范围缩小到前n-1个。**$O(n^2)$时间复杂度，不稳定（选最大时，即将交换到最后，会将后一个3被交换到前面）。**

+ 题解

  ```python
  class SelectionSort:
      def selectionSort(self, A, n):
          # write code here
          for i in range(n):
              maxNum = 0
              maxIndex = 0
              for j in range(n - i):
                  if A[j] > maxNum:
                      maxNum = A[j]
                      maxIndex = j
              A[n - i - 1], A[maxIndex] = A[maxIndex], A[n - i - 1]
          return A
  ```

### 插入排序

+ 思路：对于第i个数，插入到0-i-1部分的正确位置上。**$O(n^2)$时间复杂度，稳定（后面的3在找其正确位置时，要从后往前找，即还在前一个3的后面）。**

+ 题解

  ```python
  class InsertionSort:
      def insertionSort(self, A, n):
          # write code here
          for i in range(1, n):
              for j in range(i - 1, -1, -1):
                  if A[j + 1] < A[j]:
                      A[j + 1], A[j] = A[j], A[j + 1]
          return A
  ```

### 二路归并排序

+ 思路：初始时每个元素作为一个区间，将第1和2个区间合并，3和4个区间合并。一轮后，每个区间长度为2，再重复合并，共$\log(n)$轮。**$O(n*\log(n))$时间复杂度，稳定（由于本来左边的3和右边的3在分成两路后，在合并时遇到相等的数，还是左边优先）。**

+ 题解

  ```python
  class MergeSort:
      def mergeSort(self, A, n):
          # write code here
          if n <= 1:
              return A
          left = self.mergeSort(A[:len(A) // 2], len(A) // 2)
          right = self.mergeSort(A[len(A) // 2:], len(A) - len(A) // 2)
          
          i = j = 0
          newA = []
          while i < len(left) and j < len(right):
              if left[i] < right[j]:
                  newA.append(left[i])
                  i += 1
              else:
                  newA.append(right[j])
                  j += 1
          newA += left[i:]
          newA += right[j:]
          return newA
  ```

### 快速排序

+ 思路：将A[0]作为第一次要放到正确位置的点，自左而右找到第一个比它大的数A[i]，这个数即将被交换到右边。自右而左找到第一个比它小的数A[j]，这个数将被交换到左边。如果i<j，交换二者。否则结束，将A[0]和A[j]交换。此时j位置上的数（即原本的A[0]）已经在正确位置上，再对其左右两个部分重复快排。**$O(n*\log(n))$时间复杂度，不稳定（由于每次A[left]放到A[j]位置上了，可能会将前3放到中3和后3中间）。**

+ 题解

  ```python
  def quick(A, left, right):
      if left < right:
          i, j = left + 1, right  # 注意i和j分别从1和n-1开始，是由于A[left]是要排序的数
          while 1:
              while i <= right and A[i] <= A[left]:  # i最大为n-1
                  i += 1
              while j > left and A[j] >= A[left]:  # j最小为1，为0时不用比较
                  j -= 1
              if i < j:
                  A[i], A[j] = A[j], A[i]
              else:
                  break
          A[left], A[j] = A[j], A[left]
          quick(A, left, j - 1)
          quick(A, j + 1, right)
  
  class QuickSort:
      def quickSort(self, A, n):
          # write code here
          quick(A, 0, n - 1)
          return A
  ```

### 堆排序

+ 思路：用数组建立大顶堆，每次将最后一个元素放在第一个元素位置，原本第一个元素移出堆，放在输出列表的最后，重新维护大顶堆。初始建堆的过程，是从非叶子节点开始，向根节点走，查看该节点是否大于等于左右子节点。**$O(n*\log(n))$时间复杂度，非递归时空间复杂度为$O(1)$，不稳定（由于每次把根节点放到最后并移出堆，导致前一个3被移出，放在队列最后）。**

+ 题解

  ```python
  def adjust(A, head, n):  # 将以head开头的子树调整为大顶堆，整个树共n个节点。注意数组从0开始，子节点为(cur + 1) * 2 - 1和(cur + 1) * 2
      if len(A) < 2:
          return
      temp = A[head]
      cur = (head + 1) * 2 - 1
      while cur < n:
          if cur + 1 < n and A[cur] < A[cur + 1]:  # 找出左右节点的最大值，令为A[cur]
              cur += 1
          if A[cur] <= temp:
              break  # 找到了左右节点都小于等于A[head]的位置，结束
          A[(cur + 1) // 2 - 1] = A[cur]  # 否则将左右节点最大的升为父节点
          cur = (cur + 1) * 2 - 1
      A[(cur + 1) // 2 - 1] = temp  # 将A[head]放到该位置，即A[(cur + 1) // 2 - 1]
  
  
  class HeapSort:
      def heapSort(self, A, n):
          # write code here
          for i in range((n - 2) // 2, -1, -1):  # 初始建大顶堆，只需考虑非叶子节点是否满足节点大于其子节点
              adjust(A, i, n)
          for i in range(n - 1, 0, -1):
              A[0], A[i] = A[i], A[0]  # 堆顶放在最后
              adjust(A, 0, i)
          return A
  ```

### shell排序

+ 思路：对于步长为gap，将数组每gap个划分为一组，组内用某种排序（如冒泡），然后步长自减1，重复直至步长为1的情况排序结束。**$O(n*\log(n))$时间复杂度（不稳定，若两个3在第一次分组时不在一组，可能后面的3被调到靠前位置）。**

+ ```python
  class ShellSort:
      def shellSort(self, A, n):
          # write code here
          gap = n // 2
          while gap:
              for i in range(gap, n):
                  if A[i - gap] > A[i]:
                      A[i], A[i - gap] = A[i - gap], A[i]
              gap -= 1
          return A
  ```

### 桶排序

+ 思路：桶排序是一种思想而不是具体算法。**$O(n)$时间复杂度。**

### 计数排序

+ 思路：基本原理为桶排序，而不是比较。在排序时，对$[min,max]$范围内每个数设置一个桶，将需要排序的数放进对应桶中，然后从桶底依次倒出来（类似队列而不是栈）。**$O(n)$时间复杂度，稳定（每个桶是队列，不改变相同数的顺序）。**

+ 题解

  ```python
  class CountingSort:
      def countingSort(self, A, n):
          # write code here
          bins = [0] * (max(A) + 1)
          res = []
          for i in A:
              bins[i] += 1
          for i in range(len(bins)):
              if bins[i]:
                  for j in range(bins[i]):
                      res.append(i)
          return res
  ```

### 基数排序

+ 思路：基本原理为桶排序，而不是比较。将需要排序的数先按个位放入桶中，倒出，再按十位、百位一次进桶出桶。**$O(n)$时间复杂度，稳定（每个桶是队列，不改变相同数的顺序）。**

+ 题解

  ```python
  class RadixSort:
      def radixSort(self, A, n):
          # write code here
          for i in range(4):
              bins = [[] for _ in range(10)]
              for j in A:
                  print(j, 10 ** i, 10 ** (i - 1))
                  bins[j // (10 ** i) % 10].append(j)
              A = []
              for i in range(10):
                  for j in bins[i]:
                      A.append(j)
          return A
  ```

### 工程上的排序

+ 样本数较少，如几十，一般用插入排序。由于插入排序虽然是$O(n^2)$，但在数量较少时平方体现不出来，且计算复杂度时都是忽略了常数的，插入排序的常数较小。
+ 样本数较多时，使用不稳定的快排或稳定的归并。

### 排序选择

+ 熟记时间复杂度$O(n^2)$系列，$O(n\log(n))$系列，$O(n)$系列。熟记空间复杂度$O(1)$系列。

+ **考虑时从时间复杂度低到高考虑，即计数基数、快排归并堆shell、选择冒泡插入。如果要求空间复杂度$O(1)$，只能选非递归的堆（递归需要栈实现，消耗空间）、shell、冒泡、选择、插入**。桶排序受限于数值大小，往往不适用。

+ 快排和归并排序，与原始数据是否有序无关，在原式数据几乎有序（即每个数移动最多k步就有序）时，最优解为非递归堆排序。

  ```python
  def adjust(heap, head, n):
      if len(heap) < 2:
          return heap
      temp = heap[head]
      cur = (head + 1) * 2 - 1
      while cur < n:  # 建立小根堆
          if cur + 1 < n and heap[cur] > heap[cur + 1]:
              cur += 1  # cur为左右子节点最小值
          if heap[cur] >= temp:  # temp比左右子节点都小时结束
              break
          heap[(cur + 1) // 2 - 1] = heap[cur]
          cur = (cur + 1) * 2 - 1
      heap[(cur + 1) // 2 - 1] = temp
      return heap
  
  
  class ScaleSort:
      def sortElement(self, A, n, k):
          # write code here
          heap = A[:k + 1]  # 这里用了heap，空间复杂度不是O(1)
          for i in range((k - 1) // 2, -1, -1):  # 初始建堆，只需建前k+1个数的小顶堆，因为最小的数一定在前k+1个数里
              heap = adjust(heap, i, k + 1)
          for i in range(k, n - 1):  # 每次将堆顶的数去除，将A下一个数放在堆顶，调整为小顶堆
              A[i - k] = heap[0]
              heap[0] = A[i + 1]
              adjust(heap, 0, k + 1)
          for i in range(k + 1):  # A除了前面排好序的部分，其余已经全在堆中，开始只对堆操作，不向堆加入新值
              heap[0], heap[-1] = heap[-1], heap[0]
              A[n - k + i - 1] = heap.pop(-1)
              adjust(heap, 0, k - i)
          return A
  ```

+ 被排序数只有0，1，2，只需设置最左侧为0区，最右侧为2区，交换即可，$O(n)$时间复杂度。注意python的for迭代器不允许改变循环变量，需要改变时应用while。

  ```python
  class ThreeColor:
      def sortThreeColor(self, A, n):
          # write code here
          cur0 = 0
          cur2 = n - 1
          i = 0
          while i < n:
              if A[i] == 0:
                  A[cur0], A[i] = A[i], A[cur0]
                  cur0 += 1
              elif A[i] == 2:
                  A[cur2], A[i] = A[i], A[cur2]
                  cur2 -= 1
                  i -= 1
              i += 1
              if i < cur0 or i > cur2:
                  break
          return A
  ```

+ 给定数组，如果排序后，需要排序的最短子数组长度是多少。只需要找到需要移动的最左数和最右数。对于最右数，如果需要移动，一定是其左边部分的最大值比这个数更大，最左数同理。$O(n)$时间复杂度。

  ```python
  class Subsequence:
      def shortestSubsequence(self, A, n):
          # write code here
          if not A:
              return 0
          maxA, minA = A[0], A[-1]
          maxIndex, minIndex = 0, n - 1
          left, right = 1, 0  # 防止没有需要排序的情况
          for i in range(n):
              if A[i] > maxA:
                  maxA = A[i]
              elif A[i] < maxA:
                  right = i
          for i in range(n - 1, -1, -1):
              if A[i] < minA:
                  minA = A[i]
              elif A[i] > minA:
                  left = i
          return right - left + 1
  ```

+ 给定一个数组，返回排序后相邻元素的最大差值。利用计数排序思想，但不是将桶数量设置为max-min个，而是设置为数组长度个。对于n个数，将max-min范围划分为n个区间，不考虑最大值max，则n-1个数放进去必有至少一个空桶。最大差值即空桶两侧最值的差。$O(n)$时间复杂度。注意`//`为向下取整而不是四舍五入，同`int()`，乘法比除法保险。

  ```python
  class Gap:
      def maxGap(self, A, n):
          # write code here
          maxA, minA = max(A), min(A)
          bins = [[] for _ in range(n + 1)]
          for i in A:
              bins[(i - minA) * n // (maxA - minA)].append(i)  # 实际为int((i - minA) / ((maxA - minA) / n))，改写为乘法不会出错
          res = resLeft = 0
          for i in range(n + 1):
              if bins[i]:
                  resRight = min(bins[i])
                  res = max(resRight - resLeft, res)
                  resLeft = max(bins[i])
          return res
  ```

## 数组

### 判断数组是否有重复值

+ 题目：已知n个数，全部在0-n之间，有一些数有重复，找出任意一个重复的数。

+ 思路：
  + 哈希或字典，时间复杂度$O(n)$，空间复杂度$O(n)$。
  + 由于全部在0-n之间，从第i位开始，m=A[i]，如果i=m，则这个数放到了正确位置上，i+=1。否则将m和第m位比较，如果不同，交换两者。如果相同，则找到重复值。时间复杂度$O(n)$，空间复杂度$O(1)$。
  + 由于全部在0-n之间，遍历一遍，对于A里每一个数m，令A[m%n]+=n，这样遇到第一个大于等于n的数就是重复的数。时间复杂度$O(n)$，空间复杂度$O(1)$。
  + 如果不允许修改数组：
    + 省时间的方法为在上述方法基础上增加一个辅助数组。时间复杂度$O(n)$，空间复杂度$O(n)$。
    + 省空间的方法为不断二分查找，二分的条件是值小于还是大于n/2，阈值不断减半，每次都选值多的那一半（原理为1-4中如果没有重复，最多4个数字）。时间复杂度$O(n\log(n))$，空间复杂度$O(1)$。
  
+ 题解

  ```python
  class Solution:
      # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]
      # 函数返回True/False
      def duplicate(self, numbers, duplication):
          # write code here
          n = len(numbers)
          for m in numbers:
              realm = m % n
              if numbers[realm] >= n:
                  duplication[0] = realm
                  return True
              else:
                  numbers[realm] += n
          return False
  ```

### 二维数组中查找数

+ 题目：给定矩阵，每行从左到右、每列从上到下都是递增的，问数k在不在矩阵中。

+ 思路：从右上角开始找即可，每次比大小都能排除下面或左面的数，并将指针左移或下移，$O(m+n)$复杂度。

+ 题解

  ```python
  class Finder:
      def findX(self, mat, n, m, x):
          # write code here
          if not mat:
              return False
          curx, cury = 0, m - 1
          while 1:
              if x == mat[curx][cury]:
                  return True
              elif x > mat[curx][cury]:
                  if curx == n - 1:
                      return False
                  curx += 1
              elif x < mat[curx][cury]:
                  if cury == 0:
                      return False
                  cury -= 1
  ```

### 字符替换

+ 题目：将数组里"1"替换为"123"。
+ 思路：显然数组会变大，正向遍历并替换会出现需要移动后续元素，时间复杂度$O(n^2)$。最优解为正向遍历一遍统计有几个1需要替换，扩大数组空间，反向遍历，填充。时间复杂度$O(n)$。

## 字符串

### 判断两二叉树（字符串）是否为包含关系

+ 思路：

  + 暴力匹配，$O(m*n)$时间复杂度。

  + 将树深度优先遍历变为数组，较长的为长度为m的主字符串M，较短的为长度为n的模式串P。

    + 暴力匹配，以主字符串M每一个字符作为开头，匹配模式串P，$O(m*n)$时间复杂度。

    + 使用==KMP算法==。

      + 定义`"abcab"`的前缀集合为`["a","ab","abc","abca"]`，后缀为`["b","ab","cab","bcab"]`，可以看到前后缀不包括字符串自己。

      + 设置一个部分匹配表`PMT`，长度和模式串P相同。其中`PMT[i]`即为对模式串P的子串`P[:i+1]`的前缀集合和后缀集合的交集中，最长项长度。如`i=3`时，子串`P[:4]="abca"`中，前后缀集合的交集为`["a"]`，最长项长度为1，`PMT[3]=1`。此步骤为$O(n^2)$时间复杂度，通过优化可以变为$O(n)$时间复杂度。

      + 匹配时，如果`i`和`j`分别为主字符串`M`和模式串`P`的指针，假设在主字符串`M[i]`处、模式字符串`P[j]`处失配，那么已经匹配好的长度是`j`位，且这匹配好的`j`位字符中，前`PMT[j-1]`和后`PMT[j-1]`的字符是相同的（这是`PMT`的定义），只需将后`PMT[j-1]`的字符作为下一次比较时已经匹配好的部分，即将模式串`P`的指针设为`j=PMT[j-1]`，继续将`P[j]`和`M[i]`匹配即可。此步骤为$O(m)$时间复杂度。

        ![image.png](https://i.loli.net/2020/02/28/twjyObA3vIrWNc1.png)

      + 优化`PMT`生成算法如下：如果对于模式串`P`的一个字串`P[:x]`，前`now-1`位和后`now-1`位已经相同，即`PMT[x-1] = now-1`，那么对于末尾加了一个字符的子串`P[:x+1]`的`PMT[x]`，如果`P[now]==P[x]`，则`PMT[x]=PMT[x-1]+1`。但如果`P[now]!=P[x]`，需要将`now`缩小到子串`P[:x-2]`对应的`PMT`值，原因如图。此步骤$O(n)$时间复杂度。

        ![image.png](https://i.loli.net/2020/02/28/elAkPm7oEctuswf.png)

      + 总步骤为$O(M+N)$时间复杂度。

+ 题解

  ```python
  def generate_str(tree, treestr):  # 从树生成字符串。注意这里必须用符号标明节点为空，否则本题可能出现：大树虽然包含小树，但大树的小数部分还有子节点
      if not tree:
          return treestr + '#!'
      treestr += str(tree.val) + '!'
      treestr = generate_str(tree.left, treestr)
      treestr = generate_str(tree.right, treestr)
      return treestr
  
  
  class IdenticalTree:
      def chkIdentical(self, A, B):
          # write code here
          A_str = ""
          B_str = ""
          A_str = generate_str(A, A_str)
          B_str = generate_str(B, B_str)
          if len(A_str) > len(B_str):  # 主字符串M，模式串P
              P, M = B_str, A_str
          else:
              M, P = B_str, A_str
  		
          # 生成PMT
          PMT = [0 for _ in range(len(P))]
          now, x = 0, 1  # x从1开始
          while x < len(P):
              if P[now] == P[x]:
                  PMT[x] = PMT[x - 1] + 1
                  x += 1
                  now += 1
              elif not now:
                  PMT[x] = 0
                  x += 1
              else:
                  now = PMT[now - 1]
          print(PMT)
          
          # KMP算法
          i = 0
          j = 0
          while i < len(M):
              if j == 0 and M[i] != P[j]:  # 模式串P第一个字符就匹配不成功，主字符串向后走
                  i += 1
              elif M[i] == P[j]:  # 匹配成功
                  i += 1
                  j += 1
              else:  # 匹配一半失配，调整j位置
                  j = PMT[j - 1]
              if j == len(P):
                  return True
          return False
  ```

+ 知识点：树变为字符串时，建议设置'#!'标明空节点，'!'分割每个值。这样不会导致1和10与11和0的问题，也能避免子树包含但子树还有子节点问题。

### 判断两单词是否为乱序

+ 思路：建立哈希表（字典），长度不同一定不为乱序。

+ 题解

  ```python
  class Transform:
      def chkTransform(self, A, lena, B, lenb):
          # write code here
          if lena != lenb:
              return False
          dicA = {}
          for i in A:
              dicA[i] = dicA.get(i, 0) + 1
          for i in B:
              if i not in dicA.keys():
                  return False
              dicA[i] -= 1
              if dicA[i] < 0:
                  return False
          return True
  ```

###判断两单词是否为旋转词

+ 题目：如果str1前面任意长度挪到后面得到str2，则互为旋转词。如abc和bca和cab。

+ 思路：将str1和str1拼接为str0，可以发现str0中一定包含str1的所有旋转词。注意两字符串长度相同为前提。判断包含时，有要求复杂度条件下，使用KMP算法。

+ 题解

  ```python
  return lena == lenb and B in A+A
  ```

### 括号匹配

+ 思路：设置一个变量，遇到左括号自增，遇到右括号自减。每次自减如果小于0则不匹配。结束后如果大于0则不匹配。多个括号的题需要多个变量。这里其实就是用变量代替栈。

+ 题解
  
  ```python
  class Parenthesis:
      def chkParenthesis(self, A, n):
          # write code here
          num = 0
          for i in A:
              if i is '(':
                  num += 1
              elif i is ')':
                  num -= 1
                  if num < 0:
                      return False
          if num > 0:
              return False
          return True
  ```

### ==滑动窗口==

见[3. 无重复字符的最长子串]。

## 链表

### 链表分化

+ 题目：给定head和val，返回一个链表，要求将小于等于val的放在链表前部分，大于val的放在后部分。

+ 思路：设置两个子链表，分别保存小于等于val、大于val的节点，最后拼接。

+ 题解

  ```python
  class Divide:
      def listDivide(self, head, val):
          # write code here
          smaller = greater = None
          smaller_cur = greater_cur = None
          cur = head
          while cur:
              if cur.val <= val:
                  if not smaller:
                      smaller = cur
                      smaller_cur = cur
                  else:
                      smaller_cur.next = cur
                      smaller_cur = cur
              else:
                  if not greater:
                      greater = cur
                      greater_cur = cur
                  else:
                      greater_cur.next = cur
                      greater_cur = cur
              cur = cur.next
          head = None
          if smaller:
              smaller_cur.next = None  # 重点
              head = smaller
              cur_head = smaller_cur
          if greater:
              greater_cur.next = None  # 重点
              if not head:
                  head = greater
              else:
                  cur_head.next = greater
          return head
  ```

### 链表找中间值，并从中间值开始操作

+ 思路：
  + 暴力法：数到尾部，总数除以2，重新遍历。
  + 两个指针：一个跑2步一个跑1步，停止条件为：快指针.next.next为空，此时low指向奇数中间；快指针.next.next.next为空，此时low指向偶数的中间的第一个数。（原理可以自己画一个奇数一个偶数去数）

### 判断链表是否有环

+ 思路：
  + 哈希表
  + 两个指针：一个跑2步一个跑1步，有环总会相遇。

### 判断两无环链表是否相交

+ 思路：相交后，一定完全相同，不会再分开。只需两个链表都走到头，判断最后一个节点是否相同。

## 二叉树

### 递归DFS

+ 思路：DFS

+ 题解

  ```python
  def front(cur, result):
      if cur:
          result[0].append(cur.val)
      if cur.left:
          front(cur.left, result)
      if cur.right:
          front(cur.right, result)
      
  def middle(cur, result):
      if cur.left:
          middle(cur.left, result)
      if cur:
          result[1].append(cur.val)
      if cur.right:
          middle(cur.right, result)
      
  def back(cur, result):
      if cur.left:
          back(cur.left, result)
      if cur.right:
          back(cur.right, result)
      if cur:
          result[2].append(cur.val)
  
  class TreeToSequence:
      def convert(self, root):
          # write code here
          result = [[] for _ in range(3)]
          front(root, result)
          middle(root, result)
          back(root, result)
          return result
  ```

### ==非递归DFS==

+ 思路：DFS，用栈。前序时为每次从栈顶弹出一个，先输出，后将**右、左**节点入栈（这样左节点会先弹出）。中序为对于每个cur节点，**如果cur存在，入栈，cur变为其左节点，否则栈顶弹出cur，输出，cur变为其右节点**。后序遍历为，每次从栈顶弹出一个，**压入temp**，后将左、右节点入栈（这样temp中，中间的最后输出，然后是右，最先输出的是左），直至栈空，输出temp栈。

+ 题解
  
  ```python
  class TreeToSequence:
      def convert(self, root):
          # write code here
          result = [[] for _ in range(3)]
          
          # 前序
          stack = [root]
          while stack:
              result[0].append(stack[-1].val)
              cur = stack.pop(-1)
              if cur.right:
                  stack.append(cur.right)
              if cur.left:
                  stack.append(cur.left)
          
          # 中序
          cur = root
          stack = []
          while stack or cur:
              if cur:
                  stack.append(cur)
                  cur = cur.left
              else:
                  result[1].append(stack[-1].val)
                  cur = stack.pop(-1)
                  cur = cur.right
          
          # 后序
          stack = [root]
          temp = []
          while stack:
              temp.append(stack[-1].val)
              cur = stack.pop(-1)
              if cur.left:
                  stack.append(cur.left)
              if cur.right:
                  stack.append(cur.right)
          for i in range(len(temp) - 1, -1, -1):
              result[2].append(temp[i])
          return result
  ```

### 二叉树重建

+ 题目：根据前序和中序重建二叉树。

+ 思路：我们知道，前序为中左右，中序为左中右。前序第一个一定为根节点，在中序中找到根节点，左侧的就为其左子树，右侧为其右子树。根据左子树的节点数m，可知在前序中根节点后m个都为左子树，这样就得到了其左子树的前序和中序。同理，可得右子树的前序和中序，递归即可。

+ 题解

  ```python
  def gen(cur, left_tin, left_pre, right_tin, right_pre):
      if left_pre:  # 构造cur的左子树节点的：左子树中序、左子树前序、右子树中序、右子树前序
          left = TreeNode(left_pre[0])
          cur.left = left
          left_left_tin = left_tin[:left_tin.index(left_pre[0])]
          left_left_pre = left_pre[1: 1 + len(left_left_tin)]
          left_right_tin = left_tin[left_tin.index(left_pre[0]) + 1:]
          left_right_pre = left_pre[1 + len(left_left_tin):]
          gen(left, left_left_tin, left_left_pre, left_right_tin, left_right_pre)
  
      if right_pre:  # 构造cur的右子树节点的：左子树中序、左子树前序、右子树中序、右子树前序
          right = TreeNode(right_pre[0])
          cur.right = right
          right_left_tin = right_tin[:right_tin.index(right_pre[0])]
          right_left_pre = right_pre[1: 1 + len(right_left_tin)]
          right_right_tin = right_tin[right_tin.index(right_pre[0]) + 1:]
          right_right_pre = right_pre[1 + len(right_left_tin):]
          gen(right, right_left_tin, right_left_pre, right_right_tin, right_right_pre)
  
  
  class Solution:
      # 返回构造的TreeNode根节点
      def reConstructBinaryTree(self, pre, tin):
          # write code here
          if not pre:
              return None
  
          root = TreeNode(pre[0])
          left_tin = tin[:tin.index(pre[0])]
          left_pre = pre[1: 1 + len(left_tin)]
          right_tin = tin[tin.index(pre[0]) + 1:]
          right_pre = pre[1 + len(left_tin):]
          gen(root, left_tin, left_pre, right_tin, right_pre)
          return root
  ```

+ 知识点：python中，函数参数为数组或类，无需返回即可修改内容。

### 按层BFS

+ 题目：返回二叉树，要求广度优先遍历`BFS`，且按层输出，一行一个子list，如`[[0],[1,2],[3,4,5,6]`，难点为换行。

+ 思路：==BFS要求建立队列==，每次`pop`头节点，将该节点的左右子节点`append`。对于按层输出，设置`last`节点，标记每层最后一个节点，当`cur`到`last`节点后，进入新一层，更新last。

+ 题解

  ```python
  class TreePrinter:
      def printTree(self, root):
          # write code here
          if not root:
              return
          treeList = [root]
          last = treeList[-1]  # 指示每层最后一个节点
          resList = [[]]
          while treeList:
              cur = treeList.pop(0)
              resList[-1].append(cur.val)
              if cur.left:
                  treeList.append(cur.left)
              if cur.right:
                  treeList.append(cur.right)
              if cur == last and treeList:
                  resList.append([])
                  last = treeList[-1]
          return resList
  ```

### 二叉树下一个节点

+ 题目：给定一颗二叉树的一个节点，有指向父节点的指针。要求找到中序遍历下一个节点。

+ 思路：中序遍历为左中右，给定一个节点作为中，如果有右子节点，先找其右子树的最左，右子树没有左时，找右子节点即可。如果没有右子节点，找父节点，看当前节点是左孩子还是右孩子。如果是左孩子，父节点就是下一个，如果是右孩子，继续向上找。直至父节点不存在，则该节点没有下一个节点。

+ 题解

  ```python
  class Solution:
      def GetNext(self, pNode):
          # write code here
          if pNode.right:
              pNode = pNode.right
              while pNode.left:
                  pNode = pNode.left
              return pNode
          else:
              while 1:
                  if not pNode.next:  # 父节点
                      return None
                  prev = pNode.next
                  if prev.left and prev.left == pNode:
                      return prev
                  elif prev.right and prev.right == pNode:
                      pNode = prev
  ```

### 平衡二叉树判断

+ 题目：平衡二叉树每个结点的左子树和右子树高度差不超过1，典型平衡二叉树如：三层，除头节点外都只有左子节点。

+ 思路：对于每个节点，记录左右子树高度，同时判断左右子树是否为平衡二叉树。

+ 题解

  ```python
  def checkCur(cur, h):
      if not cur or (cur and cur.val == '#'):
          return h - 1, True
      else:
          lh, isBalanced = checkCur(cur.left, h + 1)  # cur.left当前处于第h+1层
          if not isBalanced:
              return h, isBalanced
          rh, isBalanced = checkCur(cur.right, h + 1)
          if not isBalanced or abs(lh - rh) > 1:
              isBalanced = False
              return h, isBalanced
          return max(lh, rh), isBalanced
  
  class CheckBalance:
      def check(self, root):
          # write code here
          h, isBalanced = checkCur(root, 0)
          return isBalanced
  ```

### 满二叉树判断

+ 题目：满二叉树的每个层都是满的，即每个结点，都左子树深度=右子树深度。

### 完全二叉树判断

+ 题目：完全二叉树的每个结点，都有左子树深度=右子树深度或左子树深度=右子树深度+1。

+ 思路：对于每个节点，记录左右子树高度，同时判断左右子树是否为完全二叉树。

+ 题解

  ```python
  def checkCur(cur, h):
      if not cur or (cur and cur.val == '#'):
          return h - 1, True
      else:
          lh, isFull = checkCur(cur.left, h + 1)  # cur.left当前处于第h+1层
          if not isFull:
              return h, isFull
          rh, isFull = checkCur(cur.right, h + 1)
          if not isFull or lh - rh > 1 or lh - rh < 0:
              isFull = False
              return h, isFull
          return max(lh, rh), isFull
  
  class CheckCompletion:
      def chk(self, root):
          # write code here
          h, isFull = checkCur(root, 0)
          return isFull
  ```

### 搜索二叉树（二叉查找树、二叉排序数）

+ 题目：搜索二叉树的每个节点，比其所有左子树都大，比其所有右子树都小（子树可以为空）。搜索二叉树按照中序遍历，一定升序。
+ 思路：非递归中序遍历，有序则为搜索二叉树。

## ==动态规划==

+ 实质为空间换时间，避免重复计算。主要过程为：**构造dp状态矩阵，想出状态转移方程**，考虑初始化。

### 换零钱

+ 题目：有n种面值的货币，构成aim元钱，有几种方法。

+ 思路：

  + 暴力法
  + 记忆搜索法
  + dp法：设置n行aim+1列的矩阵，第i行第j列表示使用0-i种货币时，表示j元钱的方法数。

+ ```python
  class Exchange:
      def countWays(self, penny, n, aim):
          # write code here
          # 初始化第一行和第一列
          dp = [[0 for _ in range(aim + 1)] for _ in range(n)]
          for i in range(n):
              dp[i][0] = 1
          for i in range(aim + 1):
              if i % penny[0] == 0:
                  dp[0][i] = 1
  
          for i in range(1, n):  # 由于dp[i][j]依赖于上侧的dp[i-1][j]和左侧的dp[i][j-1]，故遍历时候先行后列或先列后行均可，但一定要从左上到右下
              for j in range(1, aim + 1):
                  dp[i][j] = dp[i - 1][j] + dp[i][j - penny[i]] if j - penny[i] >= 0 else  dp[i - 1][j]  # 状态转移方程：要么不用penny[i]构成j元，要么用一张penny[i]构成j-penny[i]元。两张的情况已经在一张里
          return dp[-1][-1]
  ```

### 上台阶

+ 题目：一次只能走一步或两步，共n级台阶，有几种上法。

+ 思路：动态规划，只需建立一维dp，dp[i]表示走到第i阶的方法，$dp[i]=dp[i - 1]+dp[i-2]$，即上一级台阶或两级台阶。

+ ```python
  class GoUpstairs:
      def countWays(self, n):
          # write code here
          dp = [0 for _ in range(n + 1)]
          dp[0] = 1
          dp[1] = 1
          for i in range(2, n + 1):
              dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007
          return dp[-1]
  ```

### 走迷宫

+ 题目：矩阵每个位置都有数字，从左上角走到右下角，只能向右或向下走，求路径路过的数字之和最小值。

+ 思路：动态规划，每走到一个位置，都有两个来的方向，最小值作为当前最优解。

+ ```python
  class MinimumPath:
      def getMin(self, mmap, n, m):
          # write code here
          dp = [[0 for _ in range(m)] for _ in range(n)]
          dp[0][0] = mmap[0][0]
          for i in range(m):
              dp[0][i] = mmap[0][i] + dp[0][i - 1]
          for i in range(n):
              dp[i][0] = mmap[i][0] + dp[i - 1][0]
  
          for i in range(1, n):
              for j in range(1, m):
                  dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + mmap[i][j]
          return dp[-1][-1]
  ```

### 最长递增子序列

+ 题目：返回最长递增子序列长度，子序列不需要连续，递增指严格递增，没有等号。

+ 思路：动态规划，dp[i]表示必须以A[i]结尾的最长子序列，其以来源为i之前的所有元素结尾的最长子序列长度加一，或直接为1。

+ ```python
  class LongestIncreasingSubsequence:
      def getLIS(self, A, n):
          # write code here
          dp = [0 for _ in range(n)]
          dp[0] = 1
          for i in range(1, n):
              maxdp = 0
              for j in range(i - 1, -1, -1):
                  if A[j] < A[i] and dp[j] > maxdp:
                      maxdp = dp[j]
              dp[i] = maxdp + 1
          return max(dp)
  ```

### 最长公共子序列

+ 题目：返回两个array的最长公共子序列长度，子序列不需要连续。

+ 思路：动态规划，`dp[i][j]`表示`array1[:i+1]`和`array2[:j+1]`的最长公共子序列长度，其来源包括`dp[i-1][j]`、`dp[i][j-1]`、`dp[i-1][j]-1+1`三种

+ ```python
  class LCS:
      def findLCS(self, A, n, B, m):
          # write code here
          dp = [[0 for _ in range(n)] for _ in range(m)]
          for i in range(m):
              if A[0] in B[:i + 1]:
                  dp[i][0] = 1
          for i in range(n):
              if B[0] in A[:i + 1]:
                  dp[0][i] = 1
  
          for i in range(1, m):
              for j in range(1, n):
                  if A[j] == B[i]:
                      dp[i][j] = dp[i - 1][j - 1] + 1
                  else:
                      dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
          return max(max(dp))
  ```

### 01背包问题

+ 题目：物品有重量和价值，每个物品只能用一次，求使得背包不超过载重的最大价值。

+ 思路：动态规划，`dp[i][j]`表示前0-i件物品，最大不超过j重量时的最大价值，来源包括：不使用i件的`dp[i-1][j]`和使用i件的`dp[i-1][j-w[i]]+v[i]`

+ ```python
  class Backpack:
      def maxValue(self, w, v, n, cap):
          # write code here
          dp = [[0 for _ in range(cap + 1)] for _ in range(n)]
          for i in range(cap + 1):
              if i >= w[0]:
                  dp[0][i] = v[0]
  
          for i in range(1, n):
              for j in range(1, cap + 1):
                  if j - w[i] >= 0:
                      dp[i][j] = max(dp[i - 1][j - w[i]] + v[i], dp[i - 1][j])
                  else:
                      dp[i][j] = dp[i - 1][j]
          return max(max(dp))
  ```

### 最优编辑问题

+ 题目：给定两个字符串，长度为m和n，操作有插入、删除、替换，代价分别为c0、c1、c2，求字符串A变为字符串B的最小代价。

+ 思路：动态规划，构造(m+1)\*(n+1)的dp矩阵，`dp[i][j]`表示`A[:i]`和`B[:j]`的最优编辑（注意这里`dp[0][0]`表示`''`到`''`的最优编辑），可能的来源有4个，分别是：如果`A[i-1]=B[j-1]`则 `dp[i-1][j-1]`、或在`dp[i-1][j-1]`基础上替换最后一位、或在`dp[i-1][j]`基础上插入最后一位、或在`dp[i][j-1]`基础上删除最后一位

+ ```python
  class MinCost:
      def findMinCost(self, A, n, B, m, c0, c1, c2):
          # write code here
          dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]
          for i in range(1, m + 1):
              dp[0][i] = c0 * i
          for i in range(1, n + 1):
              dp[i][0] = c1 * i
          
          for i in range(1, n + 1):
              for j in range(1, m + 1):
                  if A[i - 1] == B[j - 1]:
                      dp[i][j] = dp[i - 1][j - 1]
                  else:
                      dp[i][j] = min(dp[i - 1][j - 1] + c2, dp[i - 1][j] + c1, dp[i][j - 1] + c0)
          return dp[-1][-1]
  ```

## 递归和循环

### 斐波那契数列

+ 题目：实现斐波那契数列，第0个为0，第1个为1，第2个为f(0)+f(1)。

+ 思路：循环代替递归。

+ 题解

  ```python
  class Solution:
      def Fibonacci(self, n):
          # write code here
          num1 = 0
          num2 = 1
          if n == 0:
              return 0
          elif n == 1:
              return 1
          n -= 1
          while n:
              res = num1 + num2
              num1 = num2
              num2 = res
              n -= 1
          return num2
  ```

# 面试

+ [公司题库](https://www.nowcoder.com/contestRoom?from=cyc_github)

+ [OS、SQL、计网、Python、Git](https://github.com/Niuyuhang03/Waking-Up)
+ [OS、SQL、计网、Linux](https://github.com/Niuyuhang03/CS-Notes)
+ [ML、DL、面经](hhttps://github.com/Niuyuhang03/Deep-Learning-Interview-Book)
+ [DL](https://zhuanlan.zhihu.com/p/48374690)
+ [面经](https://github.com/Niuyuhang03/interview_internal_reference)

+ 面试遇到算法题，应当与面试官确定要求，如是否允许额外开空间等，确认思路后再写代码。