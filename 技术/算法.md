# LeetCode

+ 题解网站[leetcode](https://github.com/azl397985856/leetcode)
+ 可视化网站[LeetCodeAnimation](https://link.zhihu.com/?target=https%3A//github.com/MisterBooo/LeetCodeAnimation)
+ 面试难度在LeetCode的中等难度水平，应达到20分钟一题

## [Top 100 Liked Questions](https://leetcode-cn.com/problemset/hot-100/)

### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

+ 题目：在list中找到两个数，满足其和为target。难点为降低时间复杂度。

+ 思路

  + 暴力法较慢，$O(n^2)$时间复杂度。
  + **哈希（字典）**，边存边遍历，注意`twoSum([3,3], 6)`测试点，$O(n)$时间复杂度。
  
+ 题解

  ```python
  class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
          nums_index = {}  # 存储num第一次出现的index，防止twoSum([3,3], 6)的测试点
          for i, num in enumerate(nums):  # 边存边遍历
              j = nums_index.get(target - num)
              if j != None:
                  return [j, i]
              nums_index[num] = i
  ```

+ 知识点
  + 拷贝
    + 赋值：`list2 = list1`，即别名，变一个list的元素时另一list也会**改变**。
    + 浅拷贝：`list2 = list1.copy()`，变一个list的元素时另一list**不变**，变一个list的元素中的元素（子元素）时另一list**改变**。
    + 深拷贝：`list2 = copy.deepcopy(list1)`，变一个list的元素时另一list**不变**，完全独立。
  + 同时遍历list的index和value：`for index, value in enumerate(list)`。
  + python字典用哈希实现，对于哈希，一般复杂度为$O(1)$，最差情况全部哈希为一样的值，复杂度为$O(n)$。

### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

+ 题目：将链表各项相加，注意进位。难点为考虑进位。

+ 思路：逐位相加，注意`(2) + (8)`测试点。

+ 题解

  ```python
  # Definition for singly-linked list.
  # class ListNode:
  #     def __init__(self, x):
  #         self.val = x
  #         self.next = None
  
  class Solution:
      def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
          carried = 0  # 进位
          head = ListNode(0)
          last = head
          while l1 or l2:
              temp = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carried 
              last.next = ListNode(temp % 10)
              last = last.next
              carried = temp // 10
              if l1:
                  l1 = l1.next
              if l2:
                  l2 = l2.next
          if carried:
              last.next = ListNode(carried)
          return head.next
  ```

+ 知识点
  + python中简写`if a != None`或`if a != 0`为`if a`。
  + python中没有c语言的三目表达式，应写成`a = b if b > c else c`。

### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

+ 题目：找到一个字符串内的最长字串，满足字串内没有重复的字母。难点为降低时间复杂度。

+ 思路

  + 暴力法，找到以每个`string[index]`开头的满足条件子串，$O(n^2)$时间复杂度。
  + ==**滑动窗口**==，即在字符串中维护一个满足条件的窗口`string[start, end]`，$O(n)$时间复杂度。
  
+ 题解

  ```python
  class Solution:
      def lengthOfLongestSubstring(self, s: str) -> int:
          res = ''  # 滑动窗口
          max_len = 0
          for char in s:
              if char not in res:
                  res += char
                  if len(res) > max_len:
                      max_len = len(res)
              else:
                  res = res[res.index(char) + 1:]
                  res += char
          return max_len
  ```

### [4. 寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

+ 题目：给两个各自有序的list，找到合并后list的中位数。难点为要求$O(\log(m+n))$时间复杂度。

+ 思路

  + 合并两个list，每次从首位各pop一个元素。$O(m+n)$时间复杂度，不符合。

  + ==**二分查找**==：看到复杂度为$\log$，显然需要二分思想。题目变为在$O(\log(m+n))$时间复杂度内找第k小的数。
  + 首先保证`nums1`短于`nums2`，此时找第`k`小的数，只需判断`nums1[k/2]`和`nums2[k/2]`谁更小，若前者更小，则`nums1[:k/2+1]`的`x`个数一定小于总数组第`k`小个数，将这一部分移除，只需找到剩余数组的第`k-x`小的数。直到需要找到剩余部分第一小的数，比较两数组首元素即可。

+ 题解

  ```python
  def minKth(nums1: List[int], start1: int, end1: int, nums2: List[int], start2: int, end2: int, k: int) -> int:  # 求第k小的数
      while 1:
          if end1 - start1 > end2 - start2:  # 保证nums1最短
              return minKth(nums2, start2, end2, nums1, start1, end1 ,k)
          if end1 - start1 < 0:  # 在nums1最短前提下，nums2不可能先于nums1空掉，则只有可能nums1为空
              return nums2[start2 + k - 1]
          if k == 1:
              return min(nums1[start1], nums2[start2])  # 要找第1小的数时，只需要比较nums1和nums2第一个数
          i = start1 + min(end1 - start1 + 1, k // 2) - 1
          j = start2 + min(end2 - start2 + 1, k // 2) - 1
          if nums1[i] <= nums2[j]:  # start1到i的数一定小于总数组第k小的数，移走x个数，此后只需要找剩余数组里第k-x小的数
              k -= i - start1 + 1
              start1 = i + 1
          else:
              k -= j - start2 + 1
              start2 = j + 1
  
  class Solution:
      def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
          if len(nums1) > len(nums2):  # 保证nums1最短
              nums1, nums2 = nums2, nums1
          m, n = len(nums1), len(nums2)
          left = (m + n + 1) // 2  # 对于m+n为奇数，第left小和第right小的数是一个数
          right = (m + n + 2) // 2
          return (minKth(nums1, 0, m - 1, nums2, 0, n - 1, left) + minKth(nums1, 0, m - 1, nums2, 0, n - 1, right)) / 2
  ```


### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

+ 题目：找到一个string内的最长回文子串。

+ 思路

  + ==**动态规划**==，状态转移方程$dp\{i,j\}=\begin{cases}true&&dp\{i+1,j-1\}\ is\ true\ and\ s[i]==s[j]\\false&& other\end{cases}$，即`dp{i,j}=(s[i]==s[j]) and dp{i+1,j-1}`，$O(n^2)$时间复杂度。显然`j>=i`，故`dp`矩阵为上三角矩阵，且`dp{i+1,j-1}`在`dp{i,j}`左下方向，故遍历时从右下往左上遍历，即外`i--`内`j++`。
  + 中心扩展法，根据回文中心遍历，注意回文中心可能为`abcba`的`c`，也可能为`abba`的`bb`，$O(n^2)$时间复杂度。

+ 题解

  ```python
  class Solution:  # 动态规划
      def longestPalindrome(self, s: str) -> str:
          length = len(s)
          if length < 2:
              return s
  
          res = ""
          dp = [[False] * length for i in range(length)]
          for i in range(length):
              if i < length - 1 and s[i] == s[i + 1]:
                  dp[i][i + 1] = True
              dp[i][i] = True
          for i in range(length - 1, -1, -1):
              for j in range(i, length):
                  if i < length - 1 and j > 0 and i + 1 <= j - 1:
                      dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
                  if dp[i][j] and j - i + 1 > len(res):
                      res = s[i : j + 1]
          return res
  
  
  class Solution:  # 中心扩展法
      def longestPalindrome(self, s: str) -> str:
          length = len(s)
          if length < 2:
              return s
  		
          res = ""
          for index in range(length):
              for bias in range(min(index + 1, length - index)):
                  if s[index - bias] == s[index + bias]:
                      if bias + bias + 1 > len(res):
                          res = s[index - bias : index + bias + 1]
                  else:
                      break
              if index != length - 1:
                  for bias in range(min(index + 1, length - index - 1)):
                      if s[index - bias] == s[index + 1 + bias]:
                          if bias + bias + 2 > len(res):
                              res = s[index - bias : index + bias + 2]
                      else:
                          break
          return res
  ```

+ 知识点

  + 初始化二维数组`[[0] * 5 for i in range(5)]`或`[[0 for i in range(5)] for i in range(5)]`。

### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)



## [Top Interview Questions](https://leetcode-cn.com/problemset/top/)

## 未分类

### 拓扑排序：[296.火星词典](https://leetcode-cn.com/problems/alien-dictionary/comments/)

+ 对于一个图，满足每个节点只出现一次，A节点在B节点前则只有A到B的边没有B到A的边，则符合拓扑排序。输出时每次选一个入度为0的节点开始输出，删除该节点，其连接的节点入度-1。

### 边遍历list边删除

+ 从后向前遍历即可。

### 进制转换[660.移除9](https://leetcode-cn.com/problems/remove-9/solution/yi-chu-9-by-leetcode/)

+ 删除所有带9的数字，求第n个。写出以后发现即求n的9进制数。

# 牛客

+ 编译器不支持`print`，报错不给行号。

## [直通BAT面试算法精讲课](https://www.nowcoder.com/study/vod/1)

### [二叉树打印](https://www.nowcoder.com/study/vod/1/1/2)

+ 题目：返回二叉树，要求广度优先遍历`BFS`，且按层输出，一行一个子list，如`[[0],[1,2],[3,4,5,6]`。

+ 思路：==BFS要求建立队列==，每次`pop`头节点，将该节点的左右子节点`append`。对于按层输出，设置`last`节点，标记每层最后一个节点，当`cur`到`last`节点后，进入新一层。

+ 题解

  ```python
  # class TreeNode:
  #     def __init__(self, x):
  #         self.val = x
  #         self.left = None
  #         self.right = None
  class TreePrinter:
      def printTree(self, root):
          # write code here
          if not root:
              return
          treeList = [root]
          last = treeList[-1]  # 指示每层最后一个节点
          resList = [[]]
          while treeList:
              cur = treeList.pop(0)
              resList[-1].append(cur.val)
              if cur.left:
                  treeList.append(cur.left)
              if cur.right:
                  treeList.append(cur.right)
              if cur == last and treeList:
                  resList.append([])
                  last = treeList[-1]
          return resList
  ```

### 找到str的旋转词

+ 题目：对于两个字符串str1和str2，如果str1前面任意长度挪到后面得到str2，则互为旋转词。如abc和bca和cab。

+ 思路：将str1和str1拼接为str0，可以发现str0中一定包含str1的所有旋转词。注意两字符串长度相同为前提。

+ 题解

  ```python
  return lena == lenb and B in A+A
  ```

### 排序

#### 冒泡排序

+ 思路：第一个和第二个比较，大者放在后面，再二三比较。一轮下来，最大的数排在了最后，此时只需排序前n-1个。$O(n^2)$时间复杂度。

+ 题解

  ```python
  class BubbleSort:
      def bubbleSort(self, A, n):
          # write code here
          for i in range(n):
              for j in range(n - i - 1):
                  if A[j] > A[j+1]:
                      A[j], A[j+1] = A[j+1], A[j]
          return A
  ```

#### 选择排序

+ 思路：在前n个数里选择最大的，放在最后，再将范围缩小到前n-1个。$O(n^2)$时间复杂度。

+ 题解

  ```python
  class SelectionSort:
      def selectionSort(self, A, n):
          # write code here
          for i in range(n):
              maxNum = 0
              maxIndex = 0
              for j in range(n - i):
                  if A[j] > maxNum:
                      maxNum = A[j]
                      maxIndex = j
              A[n - i - 1], A[maxIndex] = A[maxIndex], A[n - i - 1]
          return A
  ```

#### 插入排序

+ 思路：对于第i个数，插入到0-i-1部分的正确位置上。$O(n^2)$时间复杂度。

+ 题解

  ```python
  class InsertionSort:
      def insertionSort(self, A, n):
          # write code here
          for i in range(1, n):
              for j in range(i - 1, -1, -1):
                  if A[j + 1] < A[j]:
                      A[j + 1], A[j] = A[j], A[j + 1]
          return A
  ```

#### 二路归并排序

+ 思路：初始时每个元素作为一个区间，将第1和2个区间合并，3和4个区间合并。一轮后，每个区间长度为2，再重复合并，共$\log(n)$轮。$O(n*\log(n))$时间复杂度。

+ 题解

  ```python
  class MergeSort:
      def mergeSort(self, A, n):
          # write code here
          if n <= 1:
              return A
          left = self.mergeSort(A[:len(A) // 2], len(A) // 2)
          right = self.mergeSort(A[len(A) // 2:], len(A) - len(A) // 2)
          
          i = j = 0
          newA = []
          while i < len(left) and j < len(right):
              if left[i] < right[j]:
                  newA.append(left[i])
                  i += 1
              else:
                  newA.append(right[j])
                  j += 1
          newA += left[i:]
          newA += right[j:]
          return newA
  ```

#### 快速排序

+ 思路：将A[0]最为第一次要放到正确位置的点，自左而右找到第一个比它大的数A[i]，这个数即将被交换到右边。自右而左找到第一个比它小的数A[j]，这个数将被交换到左边。如果i<j，交换二者。否则结束，将A[0]和A[j]交换。此时j位置上的数已经在正确位置上，再对其左右两个部分重复快排。$O(n*\log(n))$时间复杂度。

+ 题解

  ```python
  def quick(A, left, right):
      if left < right:
          i, j = left + 1, right  # 注意i和j分别从1和n-1开始，是由于0是分解的数
          while 1:
              while i <= right and A[i] <= A[left]:  # i最大为n-1
                  i += 1
              while j > left and A[j] >= A[left]:  # j最小为1，为0时不用比较
                  j -= 1
              if i < j:
                  A[i], A[j] = A[j], A[i]
              else:
                  break
          A[left], A[j] = A[j], A[left]
          quick(A, left, j - 1)
          quick(A, j + 1, right)
  
  class QuickSort:
      def quickSort(self, A, n):
          # write code here
          quick(A, 0, n - 1)
          return A
  ```

#### 堆排序

+ 思路：用数组建立大顶堆，每次将最后一个元素放在第一个元素位置，原本第一个元素移出堆，放在输出列表的最后，重新维护大顶堆。初始建堆的过程，是从非叶子节点开始，向根节点走，查看该节点是否大于等于左右子节点。$O(n*\log(n))$时间复杂度。

+ 题解

  ```python
  def adjust(A, head, n):  # 将以head开头的子树调整为大顶堆，整个树共n个节点
      temp = A[head]
      cur = head * 2
      while cur < n:
          if cur + 1 < n and A[cur] < A[cur + 1]:  # 找出左右节点的最大值，为A[cur]
              cur += 1
          if A[cur] <= temp:
              break  # 找到了左右节点都小于等于A[head]的位置，结束，将A[head]放到该位置，即A[cur//2]
          A[cur // 2] = A[cur]  # 否则将左右节点最大的升为父节点
          cur *= 2
      A[cur // 2] = temp  # 将A[head]放到该位置，即A[cur//2]
  
  
  class HeapSort:
      def heapSort(self, A, n):
          # write code here
          A.insert(0, 0)
          for i in range((n + 1) // 2, 0, -1):  # 初始建大顶堆，只需考虑非叶子节点是否满足节点大于其子节点
              adjust(A, i, n + 1)
          for i in range(n, 1, -1):
              A[1], A[i] = A[i], A[1]
              adjust(A, 1, i)
          A.pop(0)
          return A
  ```

#### shell排序

+ 思路：对于步长为gap，将数组每gap个划分为一组，组内用某种排序（如冒泡），然后步长自减1，重复直至步长为1的情况排序结束。$O(n*\log(n))$时间复杂度。

+ ```python
  class ShellSort:
      def shellSort(self, A, n):
          # write code here
          gap = n // 2
          while gap:
              for i in range(gap, n):
                  if A[i - gap] > A[i]:
                      A[i], A[i - gap] = A[i - gap], A[i]
              gap -= 1
          return A
  ```