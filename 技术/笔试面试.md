# 刷题

+ 刷题网站[Leetcode](https://leetcode-cn.com)：只需完成最火100题和面试高频100题
+ 题解网站[leetcode题解](https://github.com/azl397985856/leetcode)
+ 可视化网站[LeetCodeAnimation](https://link.zhihu.com/?target=https%3A//github.com/MisterBooo/LeetCodeAnimation)
+ 面试难度在LeetCode的中等难度水平，应达到20分钟一题

## [Top 100 Liked Questions](https://leetcode-cn.com/problemset/hot-100/)

### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

+ 题目：在list中找到两个数，满足其和为target。难点为降低时间复杂度。

+ 思路

  + 暴力法较慢，$O(n^2)$时间复杂度。
  + **哈希（字典）**，边存边遍历，注意`twoSum([3,3], 6)`测试点，$O(n)$时间复杂度。
  
+ 题解

  ```python
  class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
          nums_index = {}  # 存储num第一次出现的index，防止twoSum([3,3], 6)的测试点
          for i, num in enumerate(nums):  # 边存边遍历
              j = nums_index.get(target - num)
              if j != None:
                  return [j, i]
              nums_index[num] = i
  ```

+ 知识点
  + 拷贝
    + 赋值：`list2 = list1`，即别名，变一个list的元素时另一list也会**改变**。
    + 浅拷贝：`list2 = list1.copy()`，变一个list的元素时另一list**不变**，变一个list的元素中的元素（子元素）时另一list**改变**。
    + 深拷贝：`list2 = copy.deepcopy(list1)`，变一个list的元素时另一list**不变**，完全独立。
  + 同时遍历list的index和value：`for index, value in enumerate(list)`。
  + python字典用哈希实现，对于哈希，一般复杂度为$O(1)$，最差情况全部哈希为一样的值，复杂度为$O(n)$。
  + 边遍历list边删除：从后向前遍历即可。

### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

+ 题目：将链表各项相加，注意进位。难点为考虑进位。

+ 思路：逐位相加，注意`(2) + (8)`测试点。

+ 题解

  ```python
  # Definition for singly-linked list.
  # class ListNode:
  #     def __init__(self, x):
  #         self.val = x
  #         self.next = None
  
  class Solution:
      def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
          carried = 0  # 进位
          head = ListNode(0)
          last = head
          while l1 or l2:
              temp = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carried 
              last.next = ListNode(temp % 10)
              last = last.next
              carried = temp // 10
              if l1:
                  l1 = l1.next
              if l2:
                  l2 = l2.next
          if carried:
              last.next = ListNode(carried)
          return head.next
  ```

+ 知识点
  + python中简写`if a != None`或`if a != 0`为`if a`。
  + python中没有c语言的三目表达式，应写成`a = b if b > c else c`。

### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

+ 题目：找到一个字符串内的最长字串，满足字串内没有重复的字母。难点为降低时间复杂度。

+ 思路

  + 暴力法，找到以每个`string[index]`开头的满足条件子串，$O(n^2)$时间复杂度。
  + ==**滑动窗口**==，即在字符串中维护一个满足条件的窗口`string[left, right]`，查找时用哈希表（字典），$O(n)$时间复杂度。
  
+ 题解

  ```python
  class DistinctSubstring:
      def longestSubstring(self, A, n):
          # write code here
          s = A
          left, right = 0, -1  # 滑动窗口
          max_len = 0
          dic = {}  # 记录字母上次出现位置
          for i in range(n):
              char = s[i]
              if char not in dic.keys() or dic[char] < left:
                  right += 1
                  if right - left + 1 > max_len:
                      max_len = right - left + 1
              else:
                  left = dic[char] + 1
                  right += 1
              dic[char] = i
          return max_len
  ```

### [4. 寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

+ 题目：给两个各自有序的list，找到合并后list的中位数。难点为要求$O(\log(m+n))$时间复杂度。

+ 思路

  + 合并两个list，每次从首位各pop一个元素。$O(m+n)$时间复杂度，不符合。

  + ==**二分查找**==：看到复杂度为$\log$，显然需要二分思想。题目变为在$O(\log(m+n))$时间复杂度内找第k小的数。
  + 首先保证`nums1`短于`nums2`，此时找第`k`小的数，只需判断`nums1[k/2]`和`nums2[k/2]`谁更小，若前者更小，则`nums1[:k/2+1]`的`x`个数一定小于总数组第`k`小个数，将这一部分移除，只需找到剩余数组的第`k-x`小的数。直到需要找到剩余部分第一小的数，比较两数组首元素即可。

+ 题解

  ```python
  def minKth(nums1: List[int], start1: int, end1: int, nums2: List[int], start2: int, end2: int, k: int) -> int:  # 求第k小的数
      while 1:
          if end1 - start1 > end2 - start2:  # 保证nums1最短
              return minKth(nums2, start2, end2, nums1, start1, end1 ,k)
          if end1 - start1 < 0:  # 在nums1最短前提下，nums2不可能先于nums1空掉，则只有可能nums1为空
              return nums2[start2 + k - 1]
          if k == 1:
              return min(nums1[start1], nums2[start2])  # 要找第1小的数时，只需要比较nums1和nums2第一个数
          i = start1 + min(end1 - start1 + 1, k // 2) - 1
          j = start2 + min(end2 - start2 + 1, k // 2) - 1
          if nums1[i] <= nums2[j]:  # start1到i的数一定小于总数组第k小的数，移走x个数，此后只需要找剩余数组里第k-x小的数
              k -= i - start1 + 1
              start1 = i + 1
          else:
              k -= j - start2 + 1
              start2 = j + 1
  
  class Solution:
      def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
          if len(nums1) > len(nums2):  # 保证nums1最短
              nums1, nums2 = nums2, nums1
          m, n = len(nums1), len(nums2)
          left = (m + n + 1) // 2  # 对于m+n为奇数，第left小和第right小的数是一个数
          right = (m + n + 2) // 2
          return (minKth(nums1, 0, m - 1, nums2, 0, n - 1, left) + minKth(nums1, 0, m - 1, nums2, 0, n - 1, right)) / 2
  ```


### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

+ 题目：找到一个string内的最长回文子串。

+ 思路

  + ==**动态规划**==，状态转移方程$dp\{i,j\}=\begin{cases}true&&dp\{i+1,j-1\}\ is\ true\ and\ s[i]==s[j]\\false&& other\end{cases}$，即`dp{i,j}=(s[i]==s[j]) and dp{i+1,j-1}`，$O(n^2)$时间复杂度。显然`j>=i`，故`dp`矩阵为上三角矩阵，且`dp{i+1,j-1}`在`dp{i,j}`左下方向，故遍历时从右下往左上遍历，即外`i--`内`j++`。
  + 中心扩展法，根据回文中心遍历，注意回文中心可能为`abcba`的`c`，也可能为`abba`的`bb`，$O(n^2)$时间复杂度。

+ 题解

  ```python
  class Solution:  # 动态规划
      def longestPalindrome(self, s: str) -> str:
          length = len(s)
          if length < 2:
              return s
  
          res = ""
          dp = [[False] * length for i in range(length)]
          for i in range(length):
              if i < length - 1 and s[i] == s[i + 1]:
                  dp[i][i + 1] = True
              dp[i][i] = True
          for i in range(length - 1, -1, -1):
              for j in range(i, length):
                  if i < length - 1 and j > 0 and i + 1 <= j - 1:
                      dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
                  if dp[i][j] and j - i + 1 > len(res):
                      res = s[i : j + 1]
          return res
  
  
  class Solution:  # 中心扩展法
      def longestPalindrome(self, s: str) -> str:
          length = len(s)
          if length < 2:
              return s
  		
          res = ""
          for index in range(length):
              for bias in range(min(index + 1, length - index)):
                  if s[index - bias] == s[index + bias]:
                      if bias + bias + 1 > len(res):
                          res = s[index - bias : index + bias + 1]
                  else:
                      break
              if index != length - 1:
                  for bias in range(min(index + 1, length - index - 1)):
                      if s[index - bias] == s[index + 1 + bias]:
                          if bias + bias + 2 > len(res):
                              res = s[index - bias : index + bias + 2]
                      else:
                          break
          return res
  ```

+ 知识点

  + 初始化二维数组`[[0] * 5 for i in range(5)]`或`[[0 for i in range(5)] for i in range(5)]`。

### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)



## [Top Interview Questions](https://leetcode-cn.com/problemset/top/)

## 未分类

### 拓扑排序：[296.火星词典](https://leetcode-cn.com/problems/alien-dictionary/comments/)

+ 对于一个图，满足每个节点只出现一次，A节点在B节点前则只有A到B的边没有B到A的边，则符合拓扑排序。输出时每次选一个入度为0的节点开始输出，删除该节点，其连接的节点入度-1。

### 进制转换[660.移除9](https://leetcode-cn.com/problems/remove-9/solution/yi-chu-9-by-leetcode/)

+ 删除所有带9的数字，求第n个。写出以后发现即求n的9进制数。

# 算法

+ [直通BAT面试算法精讲课](https://www.nowcoder.com/study/vod/1)：《剑指offer》的乱序讲解版，讲解不细，基本为串讲，有对应在线练习题，不讲解正确代码，但难度有，适合科班学过，准备面试用。牛客网编译器不支持`print`，报错不给行号。

## 排序

### 冒泡排序

+ 思路：第一个和第二个比较，大者放在后面，再二三比较。一轮下来，最大的数排在了最后，此时只需排序前n-1个。**$O(n^2)$时间复杂度，稳定（由于两个3一样大时，不会向后冒泡）。**

+ 题解

  ```python
  class BubbleSort:
      def bubbleSort(self, A, n):
          # write code here
          for i in range(n):
              for j in range(n - i - 1):
                  if A[j] > A[j+1]:
                      A[j], A[j+1] = A[j+1], A[j]
          return A
  ```

### 选择排序

+ 思路：在前n个数里选择最大的，放在最后，再将范围缩小到前n-1个。**$O(n^2)$时间复杂度，不稳定（选最大时，即将交换到最后，会将后一个3被交换到前面）。**

+ 题解

  ```python
  class SelectionSort:
      def selectionSort(self, A, n):
          # write code here
          for i in range(n):
              maxNum = 0
              maxIndex = 0
              for j in range(n - i):
                  if A[j] > maxNum:
                      maxNum = A[j]
                      maxIndex = j
              A[n - i - 1], A[maxIndex] = A[maxIndex], A[n - i - 1]
          return A
  ```

### 插入排序

+ 思路：对于第i个数，插入到0-i-1部分的正确位置上。**$O(n^2)$时间复杂度，稳定（后面的3在找其正确位置时，要从后往前找，即还在前一个3的后面）。**

+ 题解

  ```python
  class InsertionSort:
      def insertionSort(self, A, n):
          # write code here
          for i in range(1, n):
              for j in range(i - 1, -1, -1):
                  if A[j + 1] < A[j]:
                      A[j + 1], A[j] = A[j], A[j + 1]
          return A
  ```

### 二路归并排序

+ 思路：初始时每个元素作为一个区间，将第1和2个区间合并，3和4个区间合并。一轮后，每个区间长度为2，再重复合并，共$\log(n)$轮。**$O(n*\log(n))$时间复杂度，稳定（由于本来左边的3和右边的3在分成两路后，在合并时遇到相等的数，还是左边优先）。**

+ 题解

  ```python
  class MergeSort:
      def mergeSort(self, A, n):
          # write code here
          if n <= 1:
              return A
          left = self.mergeSort(A[:len(A) // 2], len(A) // 2)
          right = self.mergeSort(A[len(A) // 2:], len(A) - len(A) // 2)
          
          i = j = 0
          newA = []
          while i < len(left) and j < len(right):
              if left[i] < right[j]:
                  newA.append(left[i])
                  i += 1
              else:
                  newA.append(right[j])
                  j += 1
          newA += left[i:]
          newA += right[j:]
          return newA
  ```

### 快速排序

+ 思路：将A[0]作为第一次要放到正确位置的点，自左而右找到第一个比它大的数A[i]，这个数即将被交换到右边。自右而左找到第一个比它小的数A[j]，这个数将被交换到左边。如果i<j，交换二者。否则结束，将A[0]和A[j]交换。此时j位置上的数（即原本的A[0]）已经在正确位置上，再对其左右两个部分重复快排。**$O(n*\log(n))$时间复杂度，不稳定（由于每次A[left]放到A[j]位置上了，可能会将前3放到中3和后3中间）。**

+ 题解

  ```python
  def quick(A, left, right):
      if left < right:
          i, j = left + 1, right  # 注意i和j分别从1和n-1开始，是由于A[left]是要排序的数
          while 1:
              while i <= right and A[i] <= A[left]:  # i最大为n-1
                  i += 1
              while j > left and A[j] >= A[left]:  # j最小为1，为0时不用比较
                  j -= 1
              if i < j:
                  A[i], A[j] = A[j], A[i]
              else:
                  break
          A[left], A[j] = A[j], A[left]
          quick(A, left, j - 1)
          quick(A, j + 1, right)
  
  class QuickSort:
      def quickSort(self, A, n):
          # write code here
          quick(A, 0, n - 1)
          return A
  ```

### 堆排序

+ 思路：用数组建立大顶堆，每次将最后一个元素放在第一个元素位置，原本第一个元素移出堆，放在输出列表的最后，重新维护大顶堆。初始建堆的过程，是从非叶子节点开始，向根节点走，查看该节点是否大于等于左右子节点。**$O(n*\log(n))$时间复杂度，非递归时空间复杂度为$O(1)$，不稳定（由于每次把根节点放到最后并移出堆，导致前一个3被移出，放在队列最后）。**

+ 题解

  ```python
  def adjust(A, head, n):  # 将以head开头的子树调整为大顶堆，整个树共n个节点。注意数组从0开始，子节点为(cur + 1) * 2 - 1和(cur + 1) * 2
      if len(A) < 2:
          return
      temp = A[head]
      cur = (head + 1) * 2 - 1
      while cur < n:
          if cur + 1 < n and A[cur] < A[cur + 1]:  # 找出左右节点的最大值，令为A[cur]
              cur += 1
          if A[cur] <= temp:
              break  # 找到了左右节点都小于等于A[head]的位置，结束
          A[(cur + 1) // 2 - 1] = A[cur]  # 否则将左右节点最大的升为父节点
          cur = (cur + 1) * 2 - 1
      A[(cur + 1) // 2 - 1] = temp  # 将A[head]放到该位置，即A[(cur + 1) // 2 - 1]
  
  
  class HeapSort:
      def heapSort(self, A, n):
          # write code here
          for i in range((n - 2) // 2, -1, -1):  # 初始建大顶堆，只需考虑非叶子节点是否满足节点大于其子节点
              adjust(A, i, n)
          for i in range(n - 1, 0, -1):
              A[0], A[i] = A[i], A[0]  # 堆顶放在最后
              adjust(A, 0, i)
          return A
  ```

### shell排序

+ 思路：对于步长为gap，将数组每gap个划分为一组，组内用某种排序（如冒泡），然后步长自减1，重复直至步长为1的情况排序结束。**$O(n*\log(n))$时间复杂度（不稳定，若两个3在第一次分组时不在一组，可能后面的3被调到靠前位置）。**

+ ```python
  class ShellSort:
      def shellSort(self, A, n):
          # write code here
          gap = n // 2
          while gap:
              for i in range(gap, n):
                  if A[i - gap] > A[i]:
                      A[i], A[i - gap] = A[i - gap], A[i]
              gap -= 1
          return A
  ```

### 桶排序

+ 思路：桶排序是一种思想而不是具体算法。**$O(n)$时间复杂度。**

#### 计数排序

+ 思路：基本原理为桶排序，而不是比较。在排序时，对$[min,max]$范围内每个数设置一个桶，将需要排序的数放进对应桶中，然后从桶底依次倒出来（类似队列而不是栈）。**$O(n)$时间复杂度，稳定（每个桶是队列，不改变相同数的顺序）。**

+ 题解

  ```python
  class CountingSort:
      def countingSort(self, A, n):
          # write code here
          bins = [0] * (max(A) + 1)
          res = []
          for i in A:
              bins[i] += 1
          for i in range(len(bins)):
              if bins[i]:
                  for j in range(bins[i]):
                      res.append(i)
          return res
  ```

### 基数排序

+ 思路：基本原理为桶排序，而不是比较。将需要排序的数先按个位放入桶中，倒出，再按十位、百位一次进桶出桶。**$O(n)$时间复杂度，稳定（每个桶是队列，不改变相同数的顺序）。**

+ 题解

  ```python
  class RadixSort:
      def radixSort(self, A, n):
          # write code here
          for i in range(4):
              bins = [[] for _ in range(10)]
              for j in A:
                  print(j, 10 ** i, 10 ** (i - 1))
                  bins[j // (10 ** i) % 10].append(j)
              A = []
              for i in range(10):
                  for j in bins[i]:
                      A.append(j)
          return A
  ```

### 工程上的排序

+ 样本数较少，如几十，一般用插入排序。由于插入排序虽然是$O(n^2)$，但在数量较少时平方体现不出来，且计算复杂度时都是忽略了常数的，插入排序的常数较小。
+ 样本数较多时，使用不稳定的快排或稳定的归并。

### 排序选择

+ 熟记时间复杂度$O(n^2)$系列，$O(n\log(n))$系列，$O(n)$系列。熟记空间复杂度$O(1)$系列。

+ **考虑时从时间复杂度低到高考虑，即计数基数、快排归并堆shell、选择冒泡插入。如果要求空间复杂度$O(1)$，只能选非递归的堆（递归需要栈实现，消耗空间）、shell、冒泡、选择、插入**。桶排序受限于数值大小，往往不适用。

+ 快排和归并排序，与原始数据是否有序无关，在原式数据几乎有序（即每个数移动最多k步就有序）时，最优解为非递归堆排序。

  ```python
  def adjust(heap, head, n):
      if len(heap) < 2:
          return heap
      temp = heap[head]
      cur = (head + 1) * 2 - 1
      while cur < n:  # 建立小根堆
          if cur + 1 < n and heap[cur] > heap[cur + 1]:
              cur += 1  # cur为左右子节点最小值
          if heap[cur] >= temp:  # temp比左右子节点都小时结束
              break
          heap[(cur + 1) // 2 - 1] = heap[cur]
          cur = (cur + 1) * 2 - 1
      heap[(cur + 1) // 2 - 1] = temp
      return heap
  
  
  class ScaleSort:
      def sortElement(self, A, n, k):
          # write code here
          heap = A[:k + 1]  # 这里用了heap，空间复杂度不是O(1)
          for i in range((k - 1) // 2, -1, -1):  # 初始建堆，只需建前k+1个数的小顶堆，因为最小的数一定在前k+1个数里
              heap = adjust(heap, i, k + 1)
          for i in range(k, n - 1):  # 每次将堆顶的数去除，将A下一个数放在堆顶，调整为小顶堆
              A[i - k] = heap[0]
              heap[0] = A[i + 1]
              adjust(heap, 0, k + 1)
          for i in range(k + 1):  # A除了前面排好序的部分，其余已经全在堆中，开始只对堆操作，不向堆加入新值
              heap[0], heap[-1] = heap[-1], heap[0]
              A[n - k + i - 1] = heap.pop(-1)
              adjust(heap, 0, k - i)
          return A
  ```

+ 判断数组是否有重复值，一般用哈希或字典，但如果要求空间复杂度$O(1)$，最优解为非递归的堆排序，排序后看是否有相同值。

+ 被排序数只有0，1，2，只需设置最左侧为0区，最右侧为2区，交换即可，$O(n)$时间复杂度。注意python的for迭代器不允许改变循环变量，需要改变时应用while。

  ```python
  class ThreeColor:
      def sortThreeColor(self, A, n):
          # write code here
          cur0 = 0
          cur2 = n - 1
          i = 0
          while i < n:
              if A[i] == 0:
                  A[cur0], A[i] = A[i], A[cur0]
                  cur0 += 1
              elif A[i] == 2:
                  A[cur2], A[i] = A[i], A[cur2]
                  cur2 -= 1
                  i -= 1
              i += 1
              if i < cur0 or i > cur2:
                  break
          return A
  ```

+ 给定矩阵，每行从左到右、每列从上到下都是递增的，问数k在不在矩阵中。从右上角开始找即可，每次比大小都能排除下面或左面的数，并将指针左移或下移，$O(m+n)$复杂度。

  ```python
  class Finder:
      def findX(self, mat, n, m, x):
          # write code here
          if not mat:
              return False
          curx, cury = 0, m - 1
          while 1:
              if x == mat[curx][cury]:
                  return True
              elif x > mat[curx][cury]:
                  if curx == n - 1:
                      return False
                  curx += 1
              elif x < mat[curx][cury]:
                  if cury == 0:
                      return False
                  cury -= 1
  ```

+ 给定数组，如果排序后，需要排序的最短子数组长度是多少。只需要找到需要移动的最左数和最右数。对于最右数，如果需要移动，一定是其左边部分的最大值比这个数更大，最左数同理。$O(n)$时间复杂度。

  ```python
  class Subsequence:
      def shortestSubsequence(self, A, n):
          # write code here
          if not A:
              return 0
          maxA, minA = A[0], A[-1]
          maxIndex, minIndex = 0, n - 1
          left, right = 1, 0  # 防止没有需要排序的情况
          for i in range(n):
              if A[i] > maxA:
                  maxA = A[i]
              elif A[i] < maxA:
                  right = i
          for i in range(n - 1, -1, -1):
              if A[i] < minA:
                  minA = A[i]
              elif A[i] > minA:
                  left = i
          return right - left + 1
  ```

+ 给定一个数组，返回排序后相邻元素的最大差值。利用计数排序思想，但不是将桶数量设置为max-min个，而是设置为数组长度个。对于n个数，将max-min范围划分为n个区间，不考虑最大值max，则n-1个数放进去必有至少一个空桶。最大差值即空桶两侧最值的差。$O(n)$时间复杂度。注意`//`为向下取整而不是四舍五入，同`int()`，乘法比除法保险。

  ```python
  class Gap:
      def maxGap(self, A, n):
          # write code here
          maxA, minA = max(A), min(A)
          bins = [[] for _ in range(n + 1)]
          for i in A:
              bins[(i - minA) * n // (maxA - minA)].append(i)  # 实际为int((i - minA) / ((maxA - minA) / n))，改写为乘法不会出错
          res = resLeft = 0
          for i in range(n + 1):
              if bins[i]:
                  resRight = min(bins[i])
                  res = max(resRight - resLeft, res)
                  resLeft = max(bins[i])
          return res
  ```

## 字符串

### 判断两二叉树是否为包含关系

+ 思路：

  + 暴力匹配，$O(m*n)$时间复杂度。

  + 将树深度优先遍历变为数组，较长的为长度为m的主字符串M，较短的为长度为n的模式串P。

    + 暴力匹配，以主字符串M每一个字符作为开头，匹配模式串P，$O(m*n)$时间复杂度。

    + 使用==KMP算法==。

      + 定义`"abcab"`的前缀集合为`["a","ab","abc","abca"]`，后缀为`["b","ab","cab","bcab"]`，可以看到前后缀不包括字符串自己。

      + 设置一个部分匹配表`PMT`，长度和模式串P相同。其中`PMT[i]`即为对模式串P的子串`P[:i+1]`的前缀集合和后缀集合的交集中，最长项长度。如`i=3`时，子串`P[:4]="abca"`中，前后缀集合的交集为`["a"]`，最长项长度为1，`PMT[3]=1`。此步骤为$O(n^2)$时间复杂度，通过优化可以变为$O(n)$时间复杂度。

      + 匹配时，如果`i`和`j`分别为主字符串`M`和模式串`P`的指针，假设在主字符串`M[i]`处、模式字符串`P[j]`处失配，那么已经匹配好的长度是`j`位，且这匹配好的`j`位字符中，前`PMT[j-1]`和后`PMT[j-1]`的字符是相同的（这是`PMT`的定义），只需将后`PMT[j-1]`的字符作为下一次比较时已经匹配好的部分，即将模式串`P`的指针设为`j=PMT[j-1]`，继续将`P[j]`和`M[i]`匹配即可。此步骤为$O(m)$时间复杂度。

        ![image.png](https://i.loli.net/2020/02/28/twjyObA3vIrWNc1.png)

      + 优化`PMT`生成算法如下：如果对于模式串`P`的一个字串`P[:x]`，前`now-1`位和后`now-1`位已经相同，即`PMT[x-1] = now-1`，那么对于末尾加了一个字符的子串`P[:x+1]`的`PMT[x]`，如果`P[now]==P[x]`，则`PMT[x]=PMT[x-1]+1`。但如果`P[now]!=P[x]`，需要将`now`缩小到子串`P[:x-2]`对应的`PMT`值，原因如图。此步骤$O(n)$时间复杂度。

        ![image.png](https://i.loli.net/2020/02/28/elAkPm7oEctuswf.png)

      + 总步骤为$O(M+N)$时间复杂度。

+ 题解

  ```python
  def generate_str(tree, treestr):  # 从树生成字符串。注意这里必须用符号标明节点为空，否则本题可能出现：大树虽然包含小树，但大树的小数部分还有子节点
      if not tree:
          return treestr + '#!'
      treestr += str(tree.val) + '!'
      treestr = generate_str(tree.left, treestr)
      treestr = generate_str(tree.right, treestr)
      return treestr
  
  
  class IdenticalTree:
      def chkIdentical(self, A, B):
          # write code here
          A_str = ""
          B_str = ""
          A_str = generate_str(A, A_str)
          B_str = generate_str(B, B_str)
          if len(A_str) > len(B_str):  # 主字符串M，模式串P
              P, M = B_str, A_str
          else:
              M, P = B_str, A_str
  		
          # 生成PMT
          PMT = [0 for _ in range(len(P))]
          now, x = 0, 1  # x从1开始
          while x < len(P):
              if P[now] == P[x]:
                  PMT[x] = PMT[x - 1] + 1
                  x += 1
                  now += 1
              elif not now:
                  PMT[x] = 0
                  x += 1
              else:
                  now = PMT[now - 1]
          print(PMT)
          
          # KMP算法
          i = 0
          j = 0
          while i < len(M):
              if j == 0 and M[i] != P[j]:  # 模式串P第一个字符就匹配不成功，主字符串向后走
                  i += 1
              elif M[i] == P[j]:  # 匹配成功
                  i += 1
                  j += 1
              else:  # 匹配一半失配，调整j位置
                  j = PMT[j - 1]
              if j == len(P):
                  return True
          return False
  ```

+ 知识点：树变为字符串时，建议设置'#!'标明空节点，'!'分割每个值。这样不会导致1和10与11和0的问题，也能避免子树包含但子树还有子节点问题。

### 判断两单词是否为乱序

+ 思路：建立哈希表（字典），长度不同一定不为乱序。

+ 题解

  ```python
  class Transform:
      def chkTransform(self, A, lena, B, lenb):
          # write code here
          if lena != lenb:
              return False
          dicA = {}
          for i in A:
              dicA[i] = dicA.get(i, 0) + 1
          for i in B:
              if i not in dicA.keys():
                  return False
              dicA[i] -= 1
              if dicA[i] < 0:
                  return False
          return True
  ```

###判断两单词是否为旋转词

+ 题目：如果str1前面任意长度挪到后面得到str2，则互为旋转词。如abc和bca和cab。

+ 思路：将str1和str1拼接为str0，可以发现str0中一定包含str1的所有旋转词。注意两字符串长度相同为前提。判断包含时，有要求复杂度条件下，使用KMP算法。

+ 题解

  ```python
  return lena == lenb and B in A+A
  ```

### 括号匹配

+ 思路：设置一个变量，遇到左括号自增，遇到右括号自减。每次自减如果小于0则不匹配。结束后如果大于0则不匹配。多个括号的题需要多个变量。这里其实就是用变量代替栈。

+ ```python
  class Parenthesis:
      def chkParenthesis(self, A, n):
          # write code here
          num = 0
          for i in A:
              if i is '(':
                  num += 1
              elif i is ')':
                  num -= 1
                  if num < 0:
                      return False
          if num > 0:
              return False
          return True
  ```

### 滑动窗口

见[3. 无重复字符的最长子串]。

## 队列和栈

## 链表

## 二分搜索

## 二叉树

### 二叉树打印

+ 题目：返回二叉树，要求广度优先遍历`BFS`，且按层输出，一行一个子list，如`[[0],[1,2],[3,4,5,6]`。

+ 思路：==BFS要求建立队列==，每次`pop`头节点，将该节点的左右子节点`append`。对于按层输出，设置`last`节点，标记每层最后一个节点，当`cur`到`last`节点后，进入新一层。

+ 题解

  ```python
  # class TreeNode:
  #     def __init__(self, x):
  #         self.val = x
  #         self.left = None
  #         self.right = None
  class TreePrinter:
      def printTree(self, root):
          # write code here
          if not root:
              return
          treeList = [root]
          last = treeList[-1]  # 指示每层最后一个节点
          resList = [[]]
          while treeList:
              cur = treeList.pop(0)
              resList[-1].append(cur.val)
              if cur.left:
                  treeList.append(cur.left)
              if cur.right:
                  treeList.append(cur.right)
              if cur == last and treeList:
                  resList.append([])
                  last = treeList[-1]
          return resList
  ```

## 位运算

## 排列组合

## 概率

## 大数据

## 动态规划

## 智力题

# 面试

+ [公司题库](https://www.nowcoder.com/contestRoom?from=cyc_github)

+ [OS、SQL、计网、Python、Git](https://github.com/Niuyuhang03/Waking-Up)
+ [OS、SQL、计网、Linux](https://github.com/Niuyuhang03/CS-Notes)
+ [ML、DL、面经](hhttps://github.com/Niuyuhang03/Deep-Learning-Interview-Book)
+ [DL](https://zhuanlan.zhihu.com/p/48374690)
+ [面经](https://github.com/Niuyuhang03/interview_internal_reference)