# 概述
## 计算机系统概述
+ 控制管理整个计算机系统的硬件软件资源，合理组织调度计算机工作与资源分配，进而为用户和其他软件提供方便接口与环境的程序合集
+ 属于系统软件，基本特性：
    + ==并发==
    + ==共享==
    + ==虚拟==
        + 时分复用技术：处理器分时共享（虚拟处理器技术）采用多道程序设计技术
        + 空分复用技术：虚拟存储器
    + ==异步==
+ 区分并发和并行：
    + ==并发：**同一时间间隔**== 内有多道程序同时执行，实际上每个时刻只有一道程序执行，即分时交替执行。OS是并发的
    + ==并行：**同一时刻**== 完成多种工作。如多流水线和多处理机
+ 操作系统功能
    + 资源管理：处理机管理、存储器管理、文件管理、设备管理
    + 命令接口：用于用户控制作业执行
        + ==联机命令接口（交互式命令接口）==
        + ==脱机命令接口（批处理命令接口）==
    + 程序接口：用于程序员请求操作系统服务，由==系统调用==命令组成

## 操作系统发展和分类
+ 分类
    + ==批处理系统：**无交互能力**==，注重吞吐量
        + 单道批处理系统：对作业成批处理，但内存里始终保持一道作业
        + 多道批处理系统：多道程序同时进入内存，交替运行。一道因I/O请求暂停后切换另一道，而不用等待I/O，即利用CPU和外设的并行工作能力，系统开销大
    + 分时操作系统：采用分时技术，把时间片分给各联机作业。可以人机交互，响应及时
    + 实时操作系统：不需要时间片排队，可以完成紧急任务。可靠性高，资源利用率低
        + 硬实时系统：必须在规定时刻发生动作，如飞行器飞行自动控制系统fefas
        + 软实时系统：可以偶尔违反时间规定，如飞机订票系统、银行管理系统
    + 网络操作系统：网络中各种资源共享
    + 分布式计算机系统：若干计算机协同完成同一任务，并发、分布
    + 个人计算机系统：最广泛
+ ==甘特图==：坐标轴写s，不同设备之间线不同，线上写设备名，做垂直时间的延长线

## 操作系统运行环境
+ CPU状态
    + ==用户态（目态）==：运行应用程序
    + ==核心态（管态、内核态）==：运行操作系统内核程序，可以执行特权指令
    + ==用户态到内核态是**硬件实现**，内核态到用户态是OS软件实现==
+ 操作系统内核
    + 时钟管理：计时、进程切换
    + 中断机制：如鼠标键盘输入、进程管理调度、系统功能调用、设备驱动、文件访问
    + 原语：处于操作系统最低层，最接近硬件，具有原子性，执行时间短
    + 系统控制的数据结构及处理：进程管理、存储器管理、设备管理
+ 中断和异常：用户态进入核心态的方法
    + ==中断指外中断==：如I/O
    + ==异常指内中断（陷入）==：如地址越界、算术溢出、缺页中断
+ ==系统调用：操作系统向用户程序提供的接口==，==不是必须提供==
    + ==**发生调用在用户态，必须在核心态运行被调用程序**==，必须由操作系统执行
        + 用户要求操作系统服务时，要==在**用户态**==使用==访管指令==（陷入指令）产生访管中断，由==硬件==进入核心态，运行系统调用指令
        + 顺序：==传递系统调用参数、执行陷入指令、执行相应服务程序、返回用户态==
        + 程序出现异常，由硬件被动进入核心态，运行系统调用指令
+ ==微内核==相比大内核更可靠、维护难度降低，但性能==开销大==，系统更低效

## 零碎知识点
+ 缓存管理指令对用户透明
+ 库函数属于应用程序，而不属于系统调用
+ ==脱机技术用于解决设备独占问题==
+ 多道批处理相比单道，I/O设备利用率高，CPU利用率高，系统吞吐量大，但系统开销也大
+ 多任务操作系统不一定需要多个CPU，如现代计算机都支持多任务
+ ==**访管指令不是系统调用指令，只能执行在用户态**，执行访管后进入内核态==
+ ==中断处理是操作系统必须提供的功能==
+ ==读时钟、取数、存数、运算、寄存器清零、访管都有可能执行在用户态，只有中断、I/O、置时钟、系统调用、进程切换、清内存、分配系统资源、修改虚存的页表、修改用户访问权限等特权指令只能在内核态执行。核心态下只有访管不能执行，其他指令都有可能执行==。注意区分问题中执行和发生
+ ==相比子程序调用，中断还要保存**PSW程序状态字寄存器**==
+ 中断和通道实现了CPU和外设并行工作

# 进程管理（处理机管理）

## 进程与线程

### 进程
+ ==进程Process：进程是进程实体的运行过程，**是系统进行（CPU以外的）资源分配和调度的一个基本单位，是拥有资源的独立单位**==。其中资源指处理机、存储器和其他设备的时间，如处理机的时间片。==进程是动态的、过程性概念==。目的是描述程序动态执行过程，支持多道程序并发执行
+ ==进程=进程实体（进程映像）的运行过程==
+ 进程状态：5态
    + ==运行态==：单处理机每时刻最多只有一个进程处于运行态
    + ==就绪态==：已经得到处理机外的一切资源，得到处理机后就能运行
    + ==阻塞态（**等待态**）==：等待某一事件，即使得到处理机也不能运行。==**只有运行态可以变为阻塞态，阻塞态只能变为就绪态**==
    + ==创建态==
    + ==结束态==：进程即将正常结束或中断退出。==先设置结束态再释放资源==
+ 进程控制：==进程控制的程序段为原语==，由内核执行
    + 进程创建：进程创建原语
        + 分配进程识别号，申请空白PCB。若申请失败则创建失败
        + 分配资源。若资源不足则进入阻塞态
        + 初始化PCB
        + 进程进入就绪队列
    + 进程终止：正常结束，异常结束。进程终止原语
        + 根据进程标识符检索PCB，读出进程状态
        + 若为执行状态，立刻终止执行，处理机将资源分配其他进程
        + 若有子进程，终止所有子进程
        + 将其资源归还父进程或操作系统
        + 把PCB从所在队列中删除
    + 进程阻塞和唤醒
        + 进程由运行态变为阻塞态为，**主动**调用阻塞原语Block。只有运行态可以变为阻塞态
            + 找到进程标识符的PCB
            + 若为运行态，保护现场，转为阻塞态
            + 把PCB插入等待队列
        + 进程由阻塞态变为就绪态，其他相关进程调用唤醒原语Wakeup，即**被动**
            + 在等待队列中找到PCB
            + 移出队列，设置为就绪态
            + PCB插入就绪队列
    + 进程切换
        + 保存处理机上下文，包括PC等寄存器
        + 更新PCB信息
        + 把PCB一如就绪或阻塞队列
        + 选择另一个进程，更新PCB
        + 更新内存管理数据结构
        + 恢复处理机上下文
+ ==进程实体（进程映像）的组成==
    + ==进程控制块PCB==：由链接或索引组织
        + 进程标识符：PID、UID
        + 进程当前状态：进程当前状态、进程优先级等
        + 进程响应程序和数据地址：进程起始地址，进程打开文件列表指针（没有地址进程空间大小）
    + ==程序段==：多个进程可能运行同一个程序
    + ==数据段==
+ 进程通信：进程无法访问其他进程地址空间，要借助系统调用函数实现进程间通信
    + ==低级：PV操作==
    + ==高级==：以较高效率传输大量数据
        + ==**共享存储**：进程之间存在一块可直接访问的共享空间。用户进程一般不能访问其他进程空间，进程内的线程是共享进程空间的==
        + ==**消息传递**==：以格式化信息（Message）为单位
            + ==**直接通信**==：消息发送给接收进程的信息缓冲队列
            + ==**间接通信**（**信箱通信**）==：消息发送到中间实体（信箱），有发送原语和接受原语
        + ==**管道通信**：采用半双工通信==，某一时刻只能单向传输，因此双方互动通信要2个管道。==属于文件系统==。管道受限于内存大小。读写操作可能被阻塞

### 线程
+ ==线程：**CPU调度、执行、分派的基本单位**，线程之间可以直接通信，没有独立地址空间，但有自己独立栈空间，线程可以创建线程，同一进程下的线程共享其进程的资源==，并发执行。==**引入线程的目的是减小程序进程创建、切换、撤销时的开销，更好的支持多道程序并发执行**==
+ 线程=线程ID+程序计数器+寄存器集合+堆栈
+ 线程实现方式：
    + 用户级线程：所有线程管理由应用程序完成,==可以在不支持线程的os上实现==
    + 内核级线程：所有线程管理由内核完成
    + 组合方式的多线程：线程在用户空间创建、调度、同步，映射到等于或更少的内核级线程上
+ 多线程系统：线程是独立运行调度的基本单位，不同线程可以执行相同程序。多线程可以提高CPU利用率
    + 多对一：多个用户线程映射到1个内核级线程。效率高，不能并行，一个线程阻塞则整个进程阻塞。如以不同参数多次执行同一应用程序
    + 一对一：1个用户线程映射到1个内核级线程，并发性强，性能开销大。如执行一个应用程序
    + 多对多：结合两者优点，如并发执行不同应用程序
    + 一对多：如进程执行过程中加载执行不同应用程序

## 处理机调度
+ 处理机调度：分配处理机，实现进程并发执行。多道程序操作系统的基础
+ 三级调度
    + ==**高级调度（作业调度）：作业从辅存的后备队列调入就绪队列**==。每个作业只调入一次调出一次。多道批处理系统大多有
    + ==**中级调度（内存调度）**：暂时不能运行的进程从就绪队列（活动就绪）调入到阻塞队列（活动阻塞）后，调入辅存的阻塞挂起队列（静止阻塞）挂起，待资源可以满足时调入就绪挂起队列（静止就绪），**中级调度将具备条件时从就绪挂起队列调回主存就绪队列**==。提高内存利用率和系统吞吐量
    + ==**低级调度（进程调度）：进程从就绪队列变为运行态**==。所有系统必须有
+ 不能进行进程调度与切换，置系统的请求调度标志，结束后再调度切换：
    + 处理中断过程中
    + 进程在OS内核程序临界区
    + 屏蔽中断的原子操作过程中：入加锁、解锁、中断保护现场、恢复
+ 可以进行进程调度与切换的情况：
    + 非剥夺调度（非抢占方式）：发生引起调度条件+当前进程无法继续运行。系统开销小，不能用于分时和大多数实时系统
    + 剥夺调度（抢占方式）：中断、异常结束，返回现场前，若已经置请求调度标志，则马上进行进程调度和切换。提高响应效率和系统吞吐率
+ 调度算法性能指标
    + CPU利用率
    + 系统吞吐量：单位时间内CPU完成作业数量
    + ==周转时间：作业完成时间-作业**提交**时间（到达内存时间，而非开始时间）==
    + 平均周转时间：周转时间/n
    + ==**带权周转时间=周转时间/实际运行时间**==
    + ==平均带权周转时间：带权周转时间/n==
    + 等待时间：进程处于等待处理机状态的时间。评价调度算法的最重要指标
    + 响应时间：从提交请求到首次响应的时间。交互式系统中重要指标之一
+ 调度算法：
    + 先来先服务FCFS：适用于作业调度或进程调度。不可剥夺。利于CPU繁忙型，不利于I/O繁忙型
    + ==短作业/进程优先SJF==：适用于作业调度或进程调度。后备队列选最短的作业、就绪队列选最短的进程。==平均等待时间、平均周转时间最少，对长作业有饥饿现象==
        + 非剥夺式
        + ==剥夺式：比较的是**剩余**运行时间==
    + 优先权调度：适用于实时操作系统的作业调度或进程调度。分为静态优先级（创建时根据进程类型、资源要求等创建优先级）、动态优先级（根据占有CPU时间长短、等待CPU时间长短动态调整优先级）。一般==I/O型进程>计算型进程，交互型进程>非交互型进程==，系统进程>用户进程
        + 非剥夺式
        + 剥夺式
    + 高响应比优先：适用于分时操作系统的作业调度。$响应比R_P=1+\frac{等待时间}{要求服务时间}=带权周转时间$，==响应比即假设进程结束时的**带权周转时间**==
    + 时间片轮转：适用于分时操作系统进程调度。进程先来先服务，只运行1个时间片，使用完后进入就绪队列排队。虽然运行一个时间片不会被打断，但==从原理上讲属于**剥夺式**==。时间片过大退化为FCFS
        + ==t时刻进程A一个时间片结束，进程B到达，B排队在A**前面**==
        + ==时间片用完以前进程就结束，**直接开始下一时间片**，不等当前时间片的空余时间结束==
        + ==时间片中，当其他进程没到达时，当前时间片用完但进程未结束的进程直接挂到队尾，注意理解**轮转**==
    + 多级反馈队列：适用于分时操作系统的进程调度，==剥夺式==。设置多个就绪队列，新进程进入第一级队列尾，一个时间片后完后进入第2级队列==尾==。当第i级队列为空时才调度第i+1级队列。能满足各种用户需要，终端型作业用户提交交互型作业，第一级队列内完成。短批处理作业用户第二级第三级一个时间片完成。长批处理作业用户不用担心长期得不到处理

## 进程同步

### 临界资源和临界区
+ ==**临界资源：一次仅允许一个进程使用的资源。临界资源一定是共享资源**==，如公用队列、消息队列
+ ==**临界区：访问临界资源的代码**。每次只允许一个进程进入临界区==

### ==同步==
+ 又称直接制约关系，如==进程按顺序访问变量==

### 互斥
+ 又称间接制约关系，即临界区只能一个进程访问，如使用打印机。进程不能进入临界区时，立即释放处理器
+ 临界资源的访问：
    + 进入区：设置正在访问临界区标志
    + 临界区：进程中访问临界资源那段代码
    + 退出区：清除标志
    + 剩余区：代码中其他部分
+ 软件实现互斥：不满足让权等待
    + 单标志法：退出区时直接置标志turn为另一进程j。必须交替进入临界区，一个进程不再进去则另一个也无法进入
    + 双标志法先检查：先查询对方标志flag[j]再置自己标志flag[i]。可以连续访问临界区，但可能同时进入临界区
    + 双标志法后检查：先置自己标志flag[i]再查询对方标志flag[j]。可能都进不去临界区（饥饿现象）
    + ==Peterson's Algorithm==：先置自己标志位flag[i]和turn=j，再查询对方标志位flag[j]和turn，同时访问时由于turn只有一个值，故必有且只有一个进程进入临界区
+ 硬件实现互斥（低级方法、元方法）：不满足让权等待
    + 中断屏蔽：CPU只能再发生中断时引起进程切换。执行效率低，有可能用户不再开中断
    + 硬件指令：原子操作，不可被打断。适用于任意数目进程，支持多个临界区，简单，但无法实现让权等待，可能有进程一直选不上造成饥饿
        + 重复TestAndSet指令检查共享变量lock是否为False
        + 重复Swap指令交换共享变量lock和初值为True的局部变量key，检查key是否为False

### 信号量
+ 原语：不被中断执行的操作，通常由硬件实现
+ 信号量：==一种带队列的信号量满足让权等待==。由原语wait(S)和signal(S)访问，即P操作和V操作，==P和V是原语==。==P申请资源S，资源S-1，若申请前S$\le$0则等待==。==V释放资源S，资源S+1，若释放后**S$\le$0**，则唤醒就绪队列中第一个等待的进程==
+ 信号量实现同步、互斥：==PV操作**紧夹**对互斥资源的操作==，注意==while(1)==
  
    + 原则：空闲让进、忙则等待、优先等待、让权等待
+ 经典同步问题
    + 生产者消费者问题：不允许同时生产和消费。mutex、empty、full
    ```bash
    semaphore mutex=1;          // 临界区互斥信号量
    semaphore empty=n;
    semaphore full=0;
    producer(){
        while(1){
            produce an item in nextp;
            P(empty);
            P(mutex);
            add nextp to buffer;
            V(mutex);
            V(full);
        }
    }
    consumer(){
        while(1){
            P(full);
            P(mutex);
            remove an item from buffer;
            V(mutex);
            V(empty);
            consume the item;
        }
    }
    ```
    + 读者-写者问题：加入count计数器
        + ==读优先，即读写读的执行顺序为读读写，所有读结束后才释放rw=1==。count、mutex、rw
        ```bash
        int count=0;                // 当前读者数量
        semaphore mutex=1;          // 用与更新count时互斥
        semaphore rw=1;
        writer(){
            while(1){
                P(rw);
                writing;
                V(rw);
            }
        }
        reader(){
            while(1){
                P(mutex);
                if(count==0)
                    P(rw);          // 第一个读者拿rw
                count++;
                V(mutex);
                reading;
                P(mutex);
                count--;
                if(count==0)
                    V(rw);          // 最后一个读者还rw
                V(mutex);
            }
        }
        ```
        + ==读写同优先级，即读写读的执行顺序为读写读，写在排队时w=0，新来的读必须排在写后==。count、mutex、rw、w
        ```bash
        int count=0;
        semaphore mutex=1;
        semaphore rw=1;
        semaphore w=1;
        writer(){
            while(1){
                P(w);               // 写者拿w，告诉新读者不能再进入
                P(rw);
                writing;
                V(rw);
                V(w);
            }
        }
        reader(){
            while(1){
                P(w);               // 写者拿着w时，新读者无法再进入；否则可以进入
                P(mutex);
                if(count==0)
                    P(rw);          // 第一个读者拿rw
                count++;
                V(mutex);
                V(w);
                reading;
                P(mutex);
                count--;
                if(count==0)
                    V(rw);          // 最后一个读者还rw
                V(mutex);
            }
        }
        ```
    + 哲学家进餐问题：要增加限制条件
    ```bash
    semaphore chopstick[5]={1,1,1,1,1};
    ```
    + 吸烟者问题：
    ```bash
    int random;
    semaphore offer1=0;         // 提供物品组合1
    semaphore offer2=0;         // 提供物品组合2
    semaphore offer3=0;         // 提供物品组合3
    semaphore finish=1;
    process P1(){               // 供应者
        while(1){
            random=任意整数随机数;
            random=random%3;
            if(random==0)
                V(offer1);
            else if(random==1)
                V(offer2);
            else
                V(offer3);
            P(finish);
        }
    }
    process P2(){               // 抽烟者1
        while(1){
            P(offer1);
            抽烟;
            V(finish);
        }
    }
    process P3(){}              // 类似P1
    process P4(){}              // 类似P1
    ```

### 管程
+ ==管程==：数据及对数据的操作组成的软件模块，可类比Java的==抽象类==。==管程中wait、signal和PV操作不同==，wait一定会阻塞进程，进入阻塞队列
+ 组成
    + 局部于管程的共享变量说明
    + 该数据结构进行操作的一组过程
    + 对局部与管程的数据设置初始值语句
+ 特性
    + 管程内的局部数据只能被管程内的过程访问
    + 一个进程只有调用管程内过程才能访问管程内共享数据
    + ==任何时候只能有一个进程在管程内执行==

## 死锁
+ 死锁：多个进程因竞争资源而造成一种僵局
+ 死锁产生原因：
    + 不可剥夺的系统资源竞争
    + 进程推进顺序非法
+ ==**死锁产生条件：互斥、不剥夺、请求并保持、循环等待**==

### 死锁处理策略：并发度越来越高
+ ==**死锁预防：破坏一个产生条件即消除死锁**==。效率低
    + 破坏互斥条件：允许资源共享。一般不可行，如打印机资源
    + 破坏不剥夺条件：放弃已经保持的其他资源，之后重新申请。用于状态易于保存恢复的资源，如CPU寄存器和内存
    + 破坏请求并保持条件：预先静态分配法，运行前一次申请完需要的全部资源。资源被严重浪费，导致其他进程饥饿
    + 破坏循环等待条件：顺序分配法，给资源编号，必须按递增顺序申请资源，同类资源一次申请完。限制新类型设备增加，进程使用资源顺序和系统规定顺序不同时造成浪费，用户编程繁琐
+ ==**死锁避免**==：资源动态分配过程中用某种方法进入不安全状态来防止死锁。需要知道将来资源需求
    + ==**银行家算法**==：进程首次申请资源时，测试该进程对资源最大需求量是否能现存资源被满足。进程执行中申请时，先测试已占用+本次申请$\le$该进程最大需求量，再测试现存资源能否满足尚需最大资源量
        + 系统安全状态：计算分配前是否会进入不安全状态（找安全序列），进行进程分配或等待
        + 安全性算法：==先求出$需求矩阵Need=最大需求矩阵Max-分配矩阵Allocation$。重复以下步骤：比较Available向量能满足哪个进程的Need，将该进程加入安全序列，释放其分配的资源Allocation更新Available==（==**不安全不一定死锁，但死锁一定不安全**==）
+ ==**死锁检测及解除**：允许死锁，出现后解除死锁==
    + 检测
        + ==资源分配图：圆圈为进程，框为一类资源，框中圈为一个资源，请求边，分配边==。死锁定理：针对进程，找到一条请求边，该请求根据剩余资源可以满足，则删去这个进程的所有边。图中进程全部是孤立点，则可完全简化，即无死锁。==死锁即图**不可完全简化**==
    + 解除：
        + 资源剥夺法：挂起死锁进程，抢占其资源
        + 撤销进程法：强制撤销部分死锁进程，释放资源
        + 进程回退法：进程回退到足以回避死锁

## 零碎知识点
+ 不是所有进程切换都要内核支持，如只有一个内核的多对一
+ ==堆区由程序员分配和释放==，malloc内存
+ ==栈区由编译器自动分配释放，存局部变量、参数、临时变量==
+ ==全局静态区（正文段）：全局变量和静态变量==
+ 动态链接库DLL被不同进程调用，属于相同线程
+ 阻塞态只能由运行态进入；创建态时内存资源不足会进入阻塞态；创建态时CPU资源不足无影响，进入就绪态
+ 父进程创建子进程后，并行执行
+ 消息直接通信中，临界资源为消息队列，而非发送接收进程
+ n道作业的批处理系统即最多n各作业的进程在就绪队列
+ 实时操作系统不一定必须使用剥夺式，也可以使用FCFS
+ 磁盘介质存储器不是临界资源，可以多个进程并发访问
+ ==PV不是系统调用==而是原语
+ 临界资源首先要是共享资源，因此私有数据不是临界资源
+ 银行叫号问题：叫号机互斥。
    + 若n个柜员个不知上限个顾客，显然柜员有信号量empty，顾客需要设置下一个叫号数int i和下一个服务数j
    + 若1个柜员和最多n个顾客，显然顾客有信号量empty，只需为顾客设置full即可知道有无排队顾客
    + 若不能坐在座位上则立即离开，不能设置empty，因为P(empty)不满足只能等待。要设置int charis，int waitings进行比较
+ ==死锁避免不会限制用户**申请**资源顺序，而是影响分配资源的顺序。死锁预防的破坏循环等待条件才会限制申请==
+ 资源分配图中，死锁必有环

# 内存管理

## 程序装入和链接
+ 用户源程序变为内存中的程序：
    + ==**编译**==：将用户源代码编译为目标模块
    + 链接：目标模块和所需库函数链接，得到装入模块，==**得到逻辑地址**==
        + 静态链接：运行前将目标模块和库函数连接成完整可执行程序
        + 装入时动态链接：目标模块装入式，边装入边链接
        + 运行时动态链接：程序执行时再对目标模块链接
    + ==**装入**==：将装入模块装入内存，==**得到物理地址**==
        + ==**编译时**重定位==：绝对装入，编译时产生绝对地址的目标代码。只适合单道程序
        + ==静态重定位==：==**装入时**== 对目标程序中指令和数据修改，将相对地址转化为绝对地址。作业装入时必须给他分配需要的全部内存（显然不能用于虚拟存储器），运行期间不能在内存中移动
        + ==动态重定位==：装入内存时为相对地址，在程序真正 ==**执行时**== 再转化为绝对地址，需要重定位寄存器（每个程序需要一个，但寄存器太贵，则一个操作系统设置一个，进程切换时重置即可）。可将程序分配到不连续存储区，可动态申请分配内存便于程序段共享
+ 地址重定位：VA转换为PA

## 内存保护
+ CPU中设置一对上、下限寄存器，判断CPU访问主存是否越界
+ 重定位寄存器（基址寄存器）和界地址寄存器：界地址寄存器为逻辑地址最大值，重定位寄存器是物理地址最小值。如果逻辑地址小于界地址寄存器值，则加上重定位寄存器值，映射为物理地址

## 覆盖与交换：扩充内存
+ 覆盖：同一程序或进程之中，用户空间分为一个固定区和若干覆盖区，打破了必须将一个进程全部信息装入主存后才能运行的限制。已经不再使用
    + 固定区：存放程序经常活跃的部分，不会被覆盖
    + 覆盖区：存放即将访问的程序，会被覆盖
    + 其他程序放在外存
+ ==交换==：不同进程之间，==即中级调度（内存调度）==。需每个进程保证执行时间长于交换时间，影响交换时间的主要是转移时间，转移时间和所交换内存空间成正比
    + 换出：等待状态程序移到辅存
    + 换入：准备好竞争CPU的程序从辅存移到内存

## ==连续分配管理方式==
+ ==单一连续分配==：内存分为系统区和用户区。简单，无需内存保护，但只用于单用户单任务，存储器利用率低，有==内部碎片==（分区内的碎片）。可以用交换和覆盖
+ ==固定分区分配==：多道程序最简单存储管理方式，用户空间分为固定大小分区，==每个分区一个作业==。程序太大时只能覆盖，主存利用率低，有==内部碎片==。==分区大小可以相等或不等==
+ ==动态分区分配（可变分区分配）==：有==外部碎片==（分区间的碎片）
    + ==首次适应First Fit==：空闲分区按地址递增排序。最简单，最快
    + ==最佳适应Best Fit==：空闲分区按容量递增排序。性能差，==最容易产生内存碎片（外部）==
    + ==最坏适应Worst Fit==（最大适应Largest Fit）：空闲分区按容量递减。性能最差
    + ==邻近适应Next Fit（循环首次适应）==：首次适应+循环。比首次要差
+ ==**碎片：内部碎片即分出去但大于需要的空间，外部碎片即剩余空间太小分不出去的空间**==

## ==非连续分配管理方式==
+ ==**基本**分页==存储管理：2次访存，地址一维
    + 分区大小固定，由硬件实现。内部碎片很少，提高内存使用率
    + ==逻辑地址包括页号P和位移W，页号P先和**页表寄存器**中的页表长度M判越界，再根据页表寄存器中的页表始址F（物理）+P\*页表项长度得到页表项从而得到物理页号b，**物理页号b\*页面大小L**+位移W得到物理地址E==
    + 页表：页号+块号
    + 每个进程1个页表，分页对用户透明
    + ==多级页表：减少页表所占连续内存空间==，但会降低速度
+ ==**基本**分段==存储管理：2次访存，==地址二维==
    + ==分区大小不固定，按自然段划分，方便用户==，分段对用户不透明
    + ==逻辑地址包括段号S和位移W，段号S先和**段表寄存器**中的段表长度M判越界，再根据段表寄存器中的段表始址F（物理）+S*段表项长度得到段号，根据段号取出段长C和基址b，位移W和段长C判越界，再根据基址b+位移W得到物理地址E==
    + 段表：段号+段长+段始址
    + 共享段：==段号不同==，段表项相同
+ ==**基本**段页式==存储管理：3次访存，地址二维
    + 逻辑地址=段号+页号+偏移
    + ==每个进程1个段表，每段1个页表==，共多个页表

## 虚拟内存管理：扩充内存。==运行前不用全部装入内存，运行时不用全部驻留内存==
+ 局部性原理：时间局部性、空间局部性
+ ==虚拟存储器：基于局部性原理，程序运行时部分装入内存，好像为用户提供了一个比实际内存大得多的存储器==
+ ==**请求**分页==存储管理
+ ==**请求**分段==存储管理
+ ==**请求**段页式==存储管理
+ 页面置换算法
    + ==最佳置换OPT==：淘汰最长时间内不再访问的页面，==无法实现==
    + ==先进先出FIFO==：==**存在Belady异常**，所分配物理块数增大而页故障数增加==
    + 最久未使用LRU：需要排序，耗费高
    + ==时钟CLOCK（**NRU**）==：增加使用位。==该页首次进入或之后被使用，使用位置1。需要替换时，循环遍历找使用位为0的页替换，同时经过的所有使用位为1的都置为0。**置换后指针后移1页。当前指向第n页，则从第n页开始顺时针或逆时针开始找零和置零**（而不是第n+1）==
    + ==改进型CLOCK==：增加使用位和修改位。==第一轮循环遍历，找使用位和修改位都为0的。第二轮，找使用位为0**修改位**为1的，同时将经过的**使用位**置0。第三轮和第4轮重复第一轮和第二轮，必有一个页面被置换==
+ ==列表格时，行分别为访问页面、物理块号、是否命中，因此已经放入的页不能为了lru方便而更换块号==

## 页面分配策略
+ 驻留集大小：由于虚存无需全部读入，要决定将多少页读入内存。==没有固定全局，因为全局一定可变==
    + ==固定分配局部置换==：
        + ==固定：每个进程分配的物理块数量在运行中数量不变==
        + ==局部：置换时**只置换自己进程**的页面==
    + ==可变分配全局置换==：
        + ==可变：全局空闲物理块队列会给缺页进程增加物理块==
        + ==全局：设置**全局空闲物理块队列**用于分配物理块给缺页进程==
    + ==可变分配局部置换==：
        + ==可变：频繁缺页则增加物理块，缺页率低则减少物理块==
        + ==局部：置换时**只置换自己进程的页面**==
+ 调入页面时机
    + 预调页策略：一次调入相邻页
    + 请求调页策略：一次调入一页
+ 从何处调入页面：==外存分为文件区和对换区，对换区的I/O速度更快==
    + 系统有足够对换区：全部从对换区调入页面，需提前从文件区复制到对换区
    + 系统无足够对换区：==不会被修改的文件从文件区调入，换出时无需保存；可能被修改的部分从对换区调入调出==
    + UNIX方式：未运行过的页面从文件区调入，运行过的从对换区调入调出
+ ==抖动：频繁调入调出主存==，即换页时间>执行时间
+ ==工作集W：某段时间内进程访问过的页面集合（**无重复**）==，由窗口大小$\Delta$和时间t决定。为防止抖动，==一般驻留集大小>工作集大小==

## 零碎知识点
+ ==解决碎片的方法：紧凑（拼接）==
+ ==二级页表中，顶级页表最多一页==
+ 进程正在I/O操作，不能交换出内存
+ 固定分区中分区大小可以不同
+ 较好解决零头问题的存储管理方式是页式
+ 虚存**实际**容量由地址位数、内存外存容量之和决定，==**最大**容量由地址位数决定==
+ e.g.有四路组相联TLB，共16条目。Cache直接映射，行大小4B，共16组。虚地址14位，物理地址12位。字节编址。页面大小64B，访问0x03d4：
    + 页面大小64B，即6位偏移量，虚地址中虚拟页号为14-6=8位，实地址中物理页号12-6=6位。TLB有16条目/4=4组，即2位，故虚拟页号中低2位位TLB组索引，高6位为TLB标记。==虚拟地址为6TLB标记+2TLB组索引+6页内偏移=8虚拟页号+6页内偏移==。Cache行大小4B，即2位，共16组即4位，则实地址低2位为块偏移，其后4位为Cache索引，==物理地址为6Cache标记+4Cache索引+2块内偏移=6物理页号+6页内偏移==。对于给定的逻辑地址，根据TLB组索引和TLB标记和有效位看是否在TLB中，若不在，再利用虚拟页号和有效位看是否在页表Page中。若在内存中，转换为物理地址，根据Cache索引和Cache标记和有效位看是否在Cache中，否则去主存中找
+ FIFO当页帧数增加，缺页中断次数可能增加或减少
+ 多级页表，TLB命中则直接访问，t=t快+t访；TLB未命中，要逐级查慢表，即t=t快+n*t内+t访
+ 段页式：虚拟地址位数-段大小=段数，同页式。段大小中，减去页大小，除以一页的页表数，向**上**取整为页级数
+ 判断NRU下一步该替换哪一页：看最近访问时间和访问位，确定指针位置
+ 注意页式一定要用页大小*页号，段式不用

# 文件管理

### 文件
+ 文件：用户输入输出的基本单位。标识符为文件的唯一标签，文件所有信息保存在外存中的目录结构中
+ 文件操作
    + 创建文件：调用create，找空间，创建FCB，目录新建目录项
    + 写文件：指针
    + 读文件：指针（和写指针是一个）
    + 文件重定位（文件寻址）：按条件搜索目录，将当前文件位置设置为给定值
    + 删除文件：目录中删除目录项，回收空间
    + 截断文件：文件属性不变，删除文件内容，释放空间
+ 打开计数器：一个文件被多少个进程打开
+ 打开文件表：
    + 系统范围的打开文件表：索引结点+打开计数器
    + 某个进程的打开文件表：包括指向系统范围的打开文件表的指针
+ 文件创建：调用==create==，创建文件控制块FCB，FCB细分为文件名+磁盘索引结点，磁盘索引结点包括文件除了文件名以外的==控制信息==（但==没有文件内容==）。目录新建一个目录项，内容为刚才的FCB，因此==目录项=FCB=文件名+索引结点==，FCB的有序集合就是目录
+ 文件首次打开：调用==open==，根据==文件名==检索目录，找到FCB，将磁盘索引结点从磁盘调入内存，成为内存索引结点，把**索引结点和打开计数器**存放在了**系统范围的打开文件表**的新表项中。单个进程的打开文件表也新建表项，该表项指向系统范围的打开文件表，返回给用户一个**指向单个进程的打开文件表表项的指针，即为文件描述符fd或文件句柄fh**，以后操作该文件不再需要文件名，只需通过fd或fh即可
+ 文件非首次打开：调用==read==，直接根据fd或fh指针，==不用文件名==，也不用经过目录，直接操作文件
+ 文件关闭：调用close，单个进程的打开文件表删除相应表项，系统范围的打开文件表中的打开文件数目减一。减到零时，若文件修改过，将文件==控制信息==（而不是文件内容）复制到磁盘中，系统范围的打开文件表删除相应表项
+ 文件==逻辑==结构：即对用户而言
    + 无结构文件（流式文件）：适合对基本信息单位操作不多的文件，管理简单。如源程序文件、目标代码文件
    + 有结构文件（记录式文件）
        + ==顺序文件==：记录顺序排列，记录定长。批量操作效率高，能存储在磁带上，难以增删改查。共有N条记录时平均查找需要N/2条
            + 串结构：记录按时间顺序排列
            + 顺序结构：记录按关键字顺序排列
        + ==索引文件==
            + 定长记录：第i条记录首地址为i*L
            + 可变长记录：第i条记录首地址为$\Sigma_{i=0}^{i-1}L_i+i$，最后加i是由于每条记录前有1个字节指明记录长度。只能顺序查找，因此加入一个顺序文件作为索引表，**索引表**包括文件**逻辑**地址
        + ==索引顺序文件==：顺序文件==分组==建立索引，组内无序，组间有序。查找时先顺序查找索引表找到组，然后在组内顺序查找。N条记录时，分$\sqrt{N}$组，每组$\sqrt{N}$个记录，平均查找需要$\sqrt{N}/2+\sqrt{N}/2=\sqrt{N}$条
        + ==直接文件（散列文件）==：没有顺序特性，存取速度快，但可能有冲突

### 目录
+ ==**目录：文件控制块FCB的有序集合，一个FCB=一个目录项=文件名+索引结点**==
+ ==文件控制块FCB：包括文件名、**文件的物理地址（而不是FCB的）**、控制信息等==
+ ==索引结点（i结点）：包括除了文件名以外的文件的描述信息，用于将文件名和其他信息分开==
    + 磁盘索引结点：磁盘上的索引结点
    + 内存索引结点：文件打开时，磁盘索引结点被复制到内存中，==**包含指向文件的指针**==
+ ==目录结构：解决重名问题==
    + 单级目录结构：整个文件系统只有一张目录表。速度慢，不允许重名，不便于共享
    + 两级目录结构：主文件目录和用户文件目录。主文件目录记录用户名，用户文件目录记录FCB。不同用户的文件可以重名，保证文件安全，但缺乏灵活性
    + 多级目录结构（树形目录结构）：利于文件分类，但增加了磁盘访问次数，不利于文件共享
    + 无环图目录结构：树形基础上加入有向边，利于文件共享，但系统复杂

### 文件共享
+ ==基于索引节点的共享方式（硬链接）：两个目录的索引结点指到**同一个**索引结点。速度快。引用时引用文件和被引用文件都+1。即使是硬链接，其读写指针也不相同==
+ ==利用符号链实现文件共享（软链接）：用户B的目录中建立新的索引结点，其指向的文件为一个**存放真实路径的LINK文件**，访问时根据此路径去读。拥有者删除文件后创建新同名文件可能导致其他人访问错误文件。B引用A时，B计数器直接复制A，删除A时B计数器不变==

### 文件保护
+ 文件保护
    + ==口令保护==：建立和访问时提供口令。不安全
    + ==加密保护==：访问时提供密钥。需要编码和译码时间
    + ==访问控制==：给每个文件和目录增加访问控制列表，规定每个用户名及允许的访问类型。精简访问列表只有拥有者、组、其他用户

## 文件系统的实现

### 文件系统层次结构
+ 用户调用接口：提供与文件及目录有关的调用
+ 文件目录系统：管理文件目录
+ 存取控制验证：实现文件保护
+ 逻辑文件系统和文件信息缓冲区：逻辑记录转换为逻辑结构内相应块号
+ 物理文件系统：逻辑记录相对块号转换为物理地址
+ 辅助分配模块：管理辅存空间
+ 设备管理程序模块：管理设备

### 目录实现
+ 线性列表：用于线性查找
+ 哈希表：用于哈希查找。速度快，但可能有冲突

### 文件实现
+ 文件分配方式（==**如何为文件分配磁盘块**==）：对应文件物理结构，由操作系统决定
    + ==**连续分配**==：连续，==支持顺序访问和随机访问==，实现简单，==**速度快**，但不适用于文件长度动态增加==，有外部碎片
    + ==**链接分配**==：离散式，==只能顺序访问==，无外部碎片
        + 隐式链接
        + 显式链接：==把文件对应物理块的指针放在**文件分配表FAT**中，整个磁盘一张文件分配表==。检索速度快，减少访问磁盘次数
    + ==**索引分配**：每个文件有索引块==，==支持顺序访问和随机访问==，无外部碎片，但空间开销大，降低速度
+ 文件存储空间管理（对外存空闲区管理）：
    + ==空闲表法==：建空闲盘块表（包括序号、第一个空闲盘块号、空闲盘块数）
    + ==空闲链表法==：
        + 空闲盘块链
        + 空闲盘区链：一个盘区多个盘块
    + ==**位示图法**==：==每块1bit==，若0在i行j列，盘块号b=n(i-1)+j。回收时i=(b-1)/n+1，j=(b-1)%n+1。n为列数
    + ==成组链接法（UNIX法）==：可用于大型文件系统

## 磁盘：保存文件的地方，以==块==为单位读写
+ 磁盘结构
    + 磁道
    + ==扇区（盘块）==：密度中心大外侧小
    + 柱面：所有盘片上相对位置相同的磁道组成柱面
    + 簇：一条磁道的一部分，是磁盘空间==分配的基本单位==
    + 磁盘地址的表示：==柱面号·盘面号·块号==
    + 存数据时，根据磁头移动原理，==先存满**扇区**，再存满**磁道**，最后存满**柱面**==
+ 分类
    + 磁头在盘面径向上是否可动：固定头磁盘、活动头磁盘
    + 磁盘是否可以替换：固定盘磁盘、可换盘磁盘
+ ==**磁盘读写时间=寻道时间+延迟时间+传输时间**==，==寻道时间影响最大==
    + ==寻道时间$T_s=m*n+s$：磁头移动到磁道的时间=跨过n条磁道时间+启动磁臂时间。只有活动头磁盘有==
    + ==延迟时间$T_r=\frac{1}{2r}$：磁头定位到某一扇区时间=1/2\*旋转一周时间==
    + ==传输时间$T_t=\frac{b}{rN}$：读出或写入数据的时间=数据字节数b/(转速r\*一个**磁道**上字节数)==
+ 优化寻道时间：磁盘调度算法。==**题中给SCAN和C-SCAN，大多时候用LOOK和C-LOOK计算**==
    + 先来先服务FCFS：最公平，性能差
    + ==最短寻道时间优先SSTF==：选择与当前磁头最近的磁道。有饥饿现象
    + ==扫描算法SCAN（电梯算法）：**在磁头当前移动方向上**，选择与当前磁头最近的磁道，**必须走到到末端**后**折返**。**局部性差**==
    + ==循环扫描算法C-SCAN：磁头**单向移动**前提下，在磁头当前移动方向上，选择与当前磁头最近的磁道，**必须走到到末端**后**直接去另一末端**，以保证永远单向移动==
    + ==LOOK算法：SCAN前提下，快到末端时若无请求直接折返==
    + ==C-LOOK算法：C-SCAN前提下，快到末端时若无请求直接去靠近另一末端的请求处==
+ 减少延迟时间：扇区交替编号，盘面错位命名
+ 磁盘管理
    + 磁盘初始化过程
        + ==低级格式化（物理分区）：分物理扇区==，每个扇区由头、数据区域、尾部组成，头尾包含==磁盘控制器信息==
        + ==将一个或多个柱面组成分区==
        + ==**逻辑格式化**：将初始文件系统数据结构存到磁盘上==
    + 引导块：保存自举程序，用于计算机启动时初始化CPU、寄存器、内存等，起点保存在ROM中，其余部分保存在磁盘启动块上
    + 坏块
        + 简单磁盘：在文件分配表FAT表明
        + 复杂磁盘：维护磁盘坏块链表，扇区备用
+ 磁盘存放
    + 以块为单位读写
    + 一般默认磁头固定，因此先写满扇区，再写满磁道，最后写满柱面

## 零碎知识点
+ 一个文件系统的逻辑分区不能管理大于物理硬盘的容量
+ 随机存取时索引文件最快，顺序存取时顺序文件最快
+ 磁盘分时共享，但同一时刻只能有一个作业启动它
+ ==磁带只能顺序访问，磁盘可以顺序或直接==
+ FAT文件分配表可以用来管理空闲磁盘块

# I/O管理

## I/O管理
+ I/O设备类型
    + 根据使用特性
        + 人机交互类外部设备：以字节为单位，较慢。如打印机、鼠标、显示器、键盘
        + 存储设备：以块为单位，较快。如磁盘、磁带、光盘
        + 网络通信设备：速度中等。如网络接口、调制解调器
    + 根据信息交换单位
        + ==字符设备：打印机、键盘==
        + ==块设备：磁盘，速度快，**可寻址**==
+ I/O控制方式
    + ==程序查询==：由于没有中断来报告I/O结束，需要CPU不停检查。CPU和I/O串行工作，CPU利用率低
    + ==程序中断==：CPU等待I/O发来中断前，转去执行其他程序。I/O完成，发出中断信号，CPU读入一个字，写入寄存器。每个字都中断CPU，仍然消耗较多CPU时间
    + ==DMA（直接存储器存取）==：I/O和CPU之间有通路，以数据块为单位，传送过程在DMA控制器下完成，无需CPU，传送结束后才中断CPU
        + DMA控制器包括：命令/状态寄存器、内存地址寄存器、数据寄存器、数据计数器
    + ==通道控制==：基于DMA，通道控制内存位置、数据块大小等信息，一个通道可以控制多台设备与内存交换数据
        + 通道控制设备控制器，设备控制器控制设备
        + 通道技术是硬件机制
        + 通道和DMA区别：DMA需要CPU控制传输数据块大小、内存位置等，通道由通道控制这些信息；DMA控制器只能对应一台设备，通道可以控制多台设备
+ ==I/O子系统层次结构==：顺序
    + ==用户I/O软件==
    + ==设备独立性软件==（OS）
    + ==设备驱动程序==
    + ==中断处理程序==
    + ==硬件==
+ ==虚拟设备：一个物理设备变为多个逻辑设备==

## I/O核心子系统
+ I/O子系统：多种方法进行设备控制
    + I/O调度：调整I/O请求顺序
    + 缓冲区和高速缓存
        + 磁盘高速缓存：利用内存来暂存磁盘盘块。==减少IO次数，提高磁盘I/O速度==
        + ==缓冲区==：利用内存，设置缓冲区，==非空时不能冲入数据，未满时不能传出数据==。缓和CPU和I/O速度不匹配，减少CPU中断频率，提高CPU和I/O并行性。设数据I/O到缓冲区时间为T，数据从缓冲区到CPU时间为M，CPU处理数据时间为C。==画甘特图==
            + ==单缓冲：**max(T, C)+M**。CPU处理数据时就开始下一次的I/O向缓冲区输入==
            + ==双缓冲：**max(T, M+C)**。即在缓冲区向CPU输入和CPU处理的过程中，开始I/O向另一个缓冲区输入==
        + 循环缓冲
        + 缓冲池：利用队列和多个缓冲区，减少等待时间
    + 设备分配与回收：==设备控制表DCT、控制器控制表COCT、通道控制表CHCT、系统设备表SDT。先分配设备，再分配控制器，最后分配通道==
        + 独占设备：如打印机
        + 分时共享设备：如磁盘I/O
        + 虚拟设备：假脱机SPOOLing方式
    + ==**假脱机SPOOLing技术**：让外围设备同时联机操作，给用户分配到的实际是磁盘的虚拟设备==。由于磁盘是高速设备，打印机是低速设备，缓和CPU和I/O速度矛盾，==提高I/O速度、**提高独占设备利用率**、将独占设备改为共享设备、实现虚拟设备==，==以空间换时间==，无需外围设备。如共享打印机
        + ==输入时，输入设备通过**内存的输入缓冲区**送到**磁盘的输入井**。当CPU需要输入数据时，从**输入井到内存**==
        + ==输出时，从内存输出到**磁盘的输出井**。当输出设备空闲时，从**输出井经过内存的输出缓冲区到输出设备**==
        + ![SPOOLing](https://i.loli.net/2019/12/01/foqRWXEYLQuBgzc.jpg)
        + ==组成：预输入程序、井管理程序、缓输出程序==

## 零碎知识点
+ 分配共享设备不会有死锁
+ 设备控制器中用于实现设备控制的是I/O逻辑
+ 设备独立性：用户编程时使用的设备与实际使用设备无关

# 大题
+ 文件系统混合索引分配：如10位直接地址项，1位一级间接地址，3位二级间接地址，每盘块4KB，索引项4B。则每盘块$4KB/4B=2^{10}$个索引，直接访问为$10*4KB=40KB$，一级范围$2^{10}*4KB=4MB$，二级范围$3*(2^{10})^2*4KB=12GB$，最大文件$40KB+4MB+12GB$