## Python风格规范

+ [Python风格规范](https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/)
    + 空格
        + 冒号后面加空格，前面不加。同逗号。
        + 参数不加空格。
    + 循环中字符串不用+=，而是要放在list里，循环结束后`"".join(array)`。字符串是不可变的，+=会产生临时变量。
    + 命名
        + 文件名使用全小写+下划线：`graph_network.py`
        + 类名使用大驼峰命名法：`ConvLayer`
        + 函数使用全小写+下划线：`def cal_acc(self):`
        + 变量使用全小写+下划线：`cur_acc = 0`

# [Leetcode](https://leetcode-cn.com)

+ 刷题网站[Leetcode](https://leetcode-cn.com)：只需完成最火100题和面试高频100题
+ 题解网站[leetcode题解](https://github.com/azl397985856/leetcode)
+ 可视化网站[LeetCodeAnimation](https://link.zhihu.com/?target=https%3A//github.com/MisterBooo/LeetCodeAnimation)
+ 面试难度在LeetCode的中等难度水平，应达到20分钟一题

## [Top 100 Liked Questions](https://leetcode-cn.com/problemset/hot-100/)

### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

+ 题目：在list中找到两个数，满足其和为target。难点为降低时间复杂度。

+ 思路

  + 暴力法较慢，$O(n^2)$时间复杂度。
  + **哈希（字典）**，边存边遍历，注意`twoSum([3,3], 6)`测试点，$O(n)$时间复杂度。
  
+ 题解

  ```python
  class Solution:
      def twoSum(self, nums: List[int], target: int) -> List[int]:
          nums_index = {}  # 存储num第一次出现的index，防止twoSum([3,3], 6)的测试点
          for i, num in enumerate(nums):  # 边存边遍历
              j = nums_index.get(target - num)
              if j != None:
                  return [j, i]
              nums_index[num] = i
  ```

+ 知识点
  + 拷贝
    + 赋值：`list2 = list1`，即别名，变一个list的元素时另一list也会**改变**。
    + 浅拷贝：`list2 = list1.copy()`，变一个list的元素时另一list**不变**，变一个list的元素中的元素（子元素）时另一list**改变**。
    + 深拷贝：`list2 = copy.deepcopy(list1)`，变一个list的元素时另一list**不变**，完全独立。
  + 同时遍历list的index和value：`for index, value in enumerate(list)`。
  + 同时遍历dic的key和value：`for key, value in dic.items()`
  + python字典用哈希实现，对于哈希，一般复杂度为$O(1)$，最差情况全部哈希为一样的值，复杂度为$O(n)$。
  + 边遍历list边删除：从后向前遍历即可。

### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

+ 题目：将链表各项相加，注意进位。难点为考虑进位。

+ 思路：逐位相加，注意`(2) + (8)`测试点。

+ 题解

  ```python
  # Definition for singly-linked list.
  # class ListNode:
  #     def __init__(self, x):
  #         self.val = x
  #         self.next = None
  
  class Solution:
      def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
          carried = 0  # 进位
          head = ListNode(0)
          last = head
          while l1 or l2:
              temp = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carried 
              last.next = ListNode(temp % 10)
              last = last.next
              carried = temp // 10
              if l1:
                  l1 = l1.next
              if l2:
                  l2 = l2.next
          if carried:
              last.next = ListNode(carried)
          return head.next
  ```

+ 知识点
  + python中简写`if a != None`或`if a != 0`为`if a`。
  + python中没有c语言的三目表达式，应写成`a = b if b > c else c`。

### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

+ 题目：找到一个字符串内的最长字串，满足字串内没有重复的字母。难点为降低时间复杂度。

+ 思路

  + 暴力法，找到以每个`string[index]`开头的满足条件子串，$O(n^2)$时间复杂度。
  + ==**滑动窗口**==，即在字符串中维护一个满足条件的窗口`string[left, right]`，查找时用哈希表（字典），$O(n)$时间复杂度。
  
+ 题解

  ```python
  class DistinctSubstring:
      def longestSubstring(self, A, n):
          # write code here
          s = A
          left, right = 0, -1  # 滑动窗口
          max_len = 0
          dic = {}  # 记录字母上次出现位置
          for i in range(n):
              char = s[i]
              if char not in dic.keys() or dic[char] < left:
                  right += 1
                  if right - left + 1 > max_len:
                      max_len = right - left + 1
              else:
                  left = dic[char] + 1
                  right += 1
              dic[char] = i
          return max_len
  ```

### [4. 寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

+ 题目：给两个各自有序的list，找到合并后list的中位数。难点为要求$O(\log(m+n))$时间复杂度。

+ 思路

  + 合并两个list，每次从首位各pop一个元素。$O(m+n)$时间复杂度，不符合。

  + ==**二分查找**==：看到复杂度为$\log$，显然需要二分思想。题目变为在$O(\log(m+n))$时间复杂度内找第k小的数。
  + 首先保证`nums1`短于`nums2`，此时找第`k`小的数，只需判断`nums1[k/2]`和`nums2[k/2]`谁更小，若前者更小，则`nums1[:k/2+1]`的`x`个数一定小于总数组第`k`小个数，将这一部分移除，只需找到剩余数组的第`k-x`小的数。直到需要找到剩余部分第一小的数，比较两数组首元素即可。

+ 题解

  ```python
  def minKth(nums1: List[int], start1: int, end1: int, nums2: List[int], start2: int, end2: int, k: int) -> int:  # 求第k小的数
      while 1:
          if end1 - start1 > end2 - start2:  # 保证nums1最短
              return minKth(nums2, start2, end2, nums1, start1, end1 ,k)
          if end1 - start1 < 0:  # 在nums1最短前提下，nums2不可能先于nums1空掉，则只有可能nums1为空
              return nums2[start2 + k - 1]
          if k == 1:
              return min(nums1[start1], nums2[start2])  # 要找第1小的数时，只需要比较nums1和nums2第一个数
          i = start1 + min(end1 - start1 + 1, k // 2) - 1
          j = start2 + min(end2 - start2 + 1, k // 2) - 1
          if nums1[i] <= nums2[j]:  # start1到i的数一定小于总数组第k小的数，移走x个数，此后只需要找剩余数组里第k-x小的数
              k -= i - start1 + 1
              start1 = i + 1
          else:
              k -= j - start2 + 1
              start2 = j + 1
  
  class Solution:
      def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
          if len(nums1) > len(nums2):  # 保证nums1最短
              nums1, nums2 = nums2, nums1
          m, n = len(nums1), len(nums2)
          left = (m + n + 1) // 2  # 对于m+n为奇数，第left小和第right小的数是一个数
          right = (m + n + 2) // 2
          return (minKth(nums1, 0, m - 1, nums2, 0, n - 1, left) + minKth(nums1, 0, m - 1, nums2, 0, n - 1, right)) / 2
  ```


### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

+ 题目：找到一个string内的最长回文子串。

+ 思路

  + ==**动态规划**==，`dp[i][j]`表示`s[i:j+1]`是否为回文。状态转移方程$dp\{i,j\}=\begin{cases}true&&dp\{i+1,j-1\}\ is\ true\ and\ s[i]==s[j]\\false&& other\end{cases}$，即`dp{i,j}=(s[i]==s[j]) and dp{i+1,j-1}`，$O(n^2)$时间复杂度。显然`j>=i`，故`dp`矩阵为上三角矩阵，且`dp{i+1,j-1}`在`dp{i,j}`左下方向，故遍历时从右下往左上遍历，即外`i--`内`j++`。
  + 中心扩展法，根据回文中心遍历，注意回文中心可能为`abcba`的`c`，也可能为`abba`的`bb`，$O(n^2)$时间复杂度。

+ 题解

  ```python
  class Solution:  # 动态规划
      def longestPalindrome(self, s: str) -> str:
          length = len(s)
          if length < 2:
              return s
  
          res = ""
          dp = [[False] * length for i in range(length)]
          for i in range(length):  # 初始化
              if i < length - 1 and s[i] == s[i + 1]:
                  dp[i][i + 1] = True
              dp[i][i] = True
          for i in range(length - 1, -1, -1):
              for j in range(i, length):
                  if i < length - 1 and j > 0 and i + 1 <= j - 1:
                      dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
                  if dp[i][j] and j - i + 1 > len(res):
                      res = s[i : j + 1]
          return res
  
  
  class Solution:  # 中心扩展法
      def longestPalindrome(self, s: str) -> str:
          length = len(s)
          if length < 2:
              return s
  		
          res = ""
          for index in range(length):
              for bias in range(min(index + 1, length - index)):
                  if s[index - bias] == s[index + bias]:
                      if bias + bias + 1 > len(res):
                          res = s[index - bias : index + bias + 1]
                  else:
                      break
              if index != length - 1:
                  for bias in range(min(index + 1, length - index - 1)):
                      if s[index - bias] == s[index + 1 + bias]:
                          if bias + bias + 2 > len(res):
                              res = s[index - bias : index + bias + 2]
                      else:
                          break
          return res
  ```

+ 知识点

  + 初始化二维数组`[[0] * 5 for i in range(5)]`或`[[0 for i in range(5)] for i in range(5)]`。

## [Top Interview Questions](https://leetcode-cn.com/problemset/top/)

## 未分类

### [296.火星词典](https://leetcode-cn.com/problems/alien-dictionary/comments/)

+ 思路：拓扑排序。对于一个图，满足每个节点只出现一次，A节点在B节点前则只有A到B的边没有B到A的边，则符合拓扑排序。输出时每次选一个入度为0的节点开始输出，删除该节点，其连接的节点入度-1。

### 进制转换[660.移除9](https://leetcode-cn.com/problems/remove-9/solution/yi-chu-9-by-leetcode/)

+ 删除所有带9的数字，求第n个。写出以后发现即求n的9进制数。

# 剑指offer、牛客网算法课

+ [直通BAT面试算法精讲课](https://www.nowcoder.com/study/vod/1)：实际为剑指offer的讲解版，题目基本涵盖剑指offer题目，但讲解不细，基本为串讲，有对应在线练习题，不讲解正确代码，==思路讲解的很辣鸡==。难度有，适合科班学过，准备面试用。牛客网编译器不支持`print`，报错不给行号。
+ [剑指offer](https://www.nowcoder.com/ta/coding-interviews?page=1)：《剑指offer》题目的电子版。

## 查找

+ 正常查找需要$O(1)$时间复杂度，排序的数据折半查找需要$O(\log(n))$时间复杂度，建立哈希表（字典）需要$O(1)$时间复杂度。

### 找局部最小

+ 题目：数组中相邻数不相等，找到一个局部最小值的下标。局部最小值定义为左右长度1范围内，该数最小。找到任意一个局部最小即可。
+ 思路：二分搜索，$O(\log(n))$时间复杂度。

### 找元素出现的最左侧位置

+ 题目：有序数组，找元素num第一次出现的位置。

+ 思路：二分搜索，$O(\log(n))$时间复杂度。

+ 题解

  ```python
  class LeftMostAppearance:
      def findPos(self, arr, n, num):
          # write code here
          if not arr:
              return -1
          left, right = 0, n - 1
          res = -1
          while left <= right:
              mid = (left + right) // 2
              if arr[mid] == num:
                  res = mid
                  right = mid - 1
              elif arr[mid] > num:
                  right = mid - 1
              else:
                  left = mid + 1
          return res
  ```

### 求N的k次方

+ 思路：二分，将k变为二进制，每一位就是1、2、4、8，求解N的m次方时，只需$N^m=N^{m-1}*N^{m-1}$，$O(\log(n))$时间复杂度。注意次方为负数等边界值。

+ 题解

  ```python
  class Solution:
      def Power(self, base, exponent):
          # write code here
          if exponent == 1:
              return base
          elif exponent == 0:
              return 1
          elif base == 0:
              return 0
          
          binary = []
          res = []
          start = 0
          neg = 0  # 指示负数
          if exponent < 0:
              exponent *= -1
              neg = 1
          while exponent != 0:
              binary.append(exponent % 2)
              exponent //= 2
              if start == 0:
                  res.append(base)
              else:
                  res.append(res[-1] * res[-1])
              start = 1
          
          value = 1
          for i in range(len(binary)):
              if binary[i]:
                  value *= res[i]
          return value if not neg else (1 / value)
  ```

### 找一个旋转数组的最小值

+ 题目：旋转数组指将升序数组前n个移到后面，如3，4，5，1，2。

+ 思路：二分查找，中间值和左右边界值判断大小。特例：相等时，如1，1，1，0，1和1，0，1，1，1无法判断，需要顺序查找。

+ 题解

  ```python
  class Solution:
      def minNumberInRotateArray(self, rotateArray):
          # write code here
          if not rotateArray:
              return None
          
          left = 0
          right = len(rotateArray) - 1
          if rotateArray[left] < rotateArray[right]:
              return rotateArray[0]
          
          while 1:
              mid = (left + right) // 2
              if rotateArray[mid] < rotateArray[left]:
                  right = mid
                  left += 1
              elif rotateArray[mid] > rotateArray[right]:
                  left = mid + 1
              else:  # 不能判断出最小值在左边还是右边时，只能顺序查找
                  for i in range(left, right - 1):
                      if rotateArray[i] > rotateArray[i + 1]:
                          return rotateArray[i + 1]
                  break
          return rotateArray[left]  # 如[1, 1]测试点
  ```

### 找数组中出现超过一半的数字

+ 思路：哈希，$O(n)$时间复杂度。不存在时返回0。

+ 题解

    ```python
    class Solution:
        def MoreThanHalfNum_Solution(self, numbers):
            # write code here
            if not numbers:
                return 0
            dic = {}
            for i in numbers:
                dic[i] = dic.get(i, 0) + 1
                if dic[i] * 2 > len(numbers):
                    return i
            return 0
    ```

## ==排序==

### 冒泡排序

+ 思路：第一个和第二个比较，大者放在后面，再二三比较。一轮下来，最大的数排在了最后，此时只需排序前n-1个。**$O(n^2)$时间复杂度，稳定（由于两个3一样大时，不会向后冒泡）。**

+ 题解

  ```python
  class BubbleSort:
      def bubbleSort(self, A, n):
          # write code here
          for i in range(n):
              for j in range(n - i - 1):
                  if A[j] > A[j+1]:
                      A[j], A[j+1] = A[j+1], A[j]
          return A
  ```

### 选择排序

+ 思路：在前n个数里选择最大的，放在最后，再将范围缩小到前n-1个。**$O(n^2)$时间复杂度，不稳定（选最大时，即将交换到最后，会将后一个3被交换到前面）。**

+ 题解

  ```python
  class SelectionSort:
      def selectionSort(self, A, n):
          # write code here
          for i in range(n):
              maxNum = 0
              maxIndex = 0
              for j in range(n - i):
                  if A[j] > maxNum:
                      maxNum = A[j]
                      maxIndex = j
              A[n - i - 1], A[maxIndex] = A[maxIndex], A[n - i - 1]
          return A
  ```

### 插入排序

+ 思路：对于第i个数，插入到0-i-1部分的正确位置上。**$O(n^2)$时间复杂度，稳定（后面的3在找其正确位置时，要从后往前找，即还在前一个3的后面）。**

+ 题解

  ```python
  class InsertionSort:
      def insertionSort(self, A, n):
          # write code here
          for i in range(1, n):
              for j in range(i - 1, -1, -1):
                  if A[j + 1] < A[j]:
                      A[j + 1], A[j] = A[j], A[j + 1]
          return A
  ```

### 归并排序

+ 思路：初始时每个元素作为一个区间，将第1和2个区间合并，3和4个区间合并。一轮后，每个区间长度为2，再重复合并，共$\log(n)$轮。**$O(n*\log(n))$时间复杂度，稳定（由于本来左边的3和右边的3在分成两路后，在合并时遇到相等的数，还是左边优先）。**

+ 题解

  ```python
  class MergeSort:
      def mergeSort(self, A, n):
          # write code here
          if n <= 1:
              return A
          left = self.mergeSort(A[:len(A) // 2], len(A) // 2)
          right = self.mergeSort(A[len(A) // 2:], len(A) - len(A) // 2)
          
          i = j = 0
          newA = []
          while i < len(left) and j < len(right):
              if left[i] < right[j]:
                  newA.append(left[i])
                  i += 1
              else:
                  newA.append(right[j])
                  j += 1
          newA += left[i:]
          newA += right[j:]
          return newA
  ```

### 快速排序

+ 思路：将A[0]作为第一次要放到正确位置的点，自左而右找到第一个比它大的数A[i]，这个数即将被交换到右边。自右而左找到第一个比它小的数A[j]，这个数将被交换到左边。如果i<j，交换二者。否则结束，将A[0]和A[j]交换。此时j位置上的数（即原本的A[0]）已经在正确位置上，再对其左右两个部分重复快排。**$O(n*\log(n))$时间复杂度，不稳定（由于每次A[left]放到A[j]位置上了，可能会将前3放到中3和后3中间）。**

+ 题解

  ```python
  def quick(A, left, right):  # left和right分别从有意义的位置0和n-1开始
      if left < right:
          i, j = left + 1, right  # 注意i从1开始，是由于A[left]是要排序的数，任何时候不能碰A[left]
          while 1:
              while i <= right and A[i] <= A[left]:  # i最大为n-1
                  i += 1
              while j > left and A[j] >= A[left]:  # j最小为1，为left时不用比较
                  j -= 1
              if i < j:
                  A[i], A[j] = A[j], A[i]
              else:
                  break  # 注意
          A[left], A[j] = A[j], A[left]
          quick(A, left, j - 1)
          quick(A, j + 1, right)
  
  class QuickSort:
      def quickSort(self, A, n):
          # write code here
          quick(A, 0, n - 1)
          return A
  ```

### 堆排序

+ 思路：用数组建立大顶堆，每次将最后一个元素放在第一个元素位置，原本第一个元素移出堆，放在输出列表的最后，重新维护大顶堆。初始建堆的过程，是从非叶子节点开始，向根节点走，查看该节点是否大于等于左右子节点。**$O(n*\log(n))$时间复杂度，非递归时空间复杂度为$O(1)$，不稳定（由于每次把根节点放到最后并移出堆，导致前一个3被移出，放在队列最后）。**

+ 题解

  ```python
  def adjust(A, head, n):  # 将以head开头的子树调整为大顶堆，整个树共n个节点。注意数组从0开始，子节点为(cur + 1) * 2 - 1和(cur + 1) * 2
      if len(A) < 2:
          return
      temp = A[head]
      cur = (head + 1) * 2 - 1
      while cur < n:
          if cur + 1 < n and A[cur] < A[cur + 1]:  # 找出左右节点的最大值，令为A[cur]
              cur += 1
          if A[cur] <= temp:
              break  # 找到了左右节点都小于等于A[head]的位置，结束
          A[(cur + 1) // 2 - 1] = A[cur]  # 否则将左右节点最大的升为父节点
          cur = (cur + 1) * 2 - 1
      A[(cur + 1) // 2 - 1] = temp  # 将A[head]放到该位置，即A[(cur + 1) // 2 - 1]
  
  
  class HeapSort:
      def heapSort(self, A, n):
          # write code here
          for i in range((n - 2) // 2, -1, -1):  # 初始建大顶堆，只需考虑非叶子节点是否满足节点大于其子节点
              adjust(A, i, n)
          for i in range(n - 1, 0, -1):
              A[0], A[i] = A[i], A[0]  # 堆顶放在最后
              adjust(A, 0, i)
          return A
  ```

### shell排序

+ 思路：对于步长为gap，将数组每gap个划分为一组，组内用某种排序（如冒泡），然后步长自减1，重复直至步长为1的情况排序结束。**$O(n*\log(n))$时间复杂度（不稳定，若两个3在第一次分组时不在一组，可能后面的3被调到靠前位置）。**

+ ```python
  class ShellSort:
      def shellSort(self, A, n):
          # write code here
          gap = n // 2
          while gap:
              for i in range(gap, n):
                  if A[i - gap] > A[i]:
                      A[i], A[i - gap] = A[i - gap], A[i]
              gap -= 1
          return A
  ```

### 桶排序

+ 思路：桶排序是一种思想而不是具体算法。**$O(n)$时间复杂度。**

### 计数排序

+ 思路：基本原理为桶排序，而不是比较。在排序时，对$[min,max]$范围内每个数设置一个桶，将需要排序的数放进对应桶中，然后从桶底依次倒出来（类似队列而不是栈）。**$O(n)$时间复杂度，稳定（每个桶是队列，不改变相同数的顺序）。**

+ 题解

  ```python
  class CountingSort:
      def countingSort(self, A, n):
          # write code here
          bins = [0] * (max(A) + 1)
          res = []
          for i in A:
              bins[i] += 1
          for i in range(len(bins)):
              if bins[i]:
                  for j in range(bins[i]):
                      res.append(i)
          return res
  ```

### 基数排序

+ 思路：基本原理为桶排序，而不是比较。将需要排序的数先按个位放入桶中，倒出，再按十位、百位一次进桶出桶。**$O(n)$时间复杂度，稳定（每个桶是队列，不改变相同数的顺序）。**

+ 题解

  ```python
  class RadixSort:
      def radixSort(self, A, n):
          # write code here
          for i in range(4):
              bins = [[] for _ in range(10)]
              for j in A:
                  print(j, 10 ** i, 10 ** (i - 1))
                  bins[j // (10 ** i) % 10].append(j)
              A = []
              for i in range(10):
                  for j in bins[i]:
                      A.append(j)
          return A
  ```

### 工程上的排序

+ 样本数较少，如几十，一般用插入排序。由于插入排序虽然是$O(n^2)$，但在数量较少时平方体现不出来，且计算复杂度时都是忽略了常数的，插入排序的常数较小。
+ 样本数较多时，使用不稳定的快排或稳定的归并。

### 排序选择

+ 熟记时间复杂度$O(n^2)$系列，$O(n\log(n))$系列，$O(n)$系列。熟记空间复杂度$O(1)$系列。

+ ==**考虑时从时间复杂度低到高考虑，即计数基数、快排归并堆shell、选择冒泡插入。如果要求空间复杂度$O(1)$，只能选非递归的堆（递归需要栈实现，消耗空间）、shell、冒泡、选择、插。若要求稳定和速度，只能桶排序或归并**。桶排序受限于数值大小，往往不适用。==

+ 快排和归并排序，与原始数据是否有序无关，在原式数据几乎有序（即每个数移动最多k步就有序）时，最优解为非递归堆排序。

  ```python
  def adjust(heap, head, n):
      if len(heap) < 2:
          return heap
      temp = heap[head]
      cur = (head + 1) * 2 - 1
      while cur < n:  # 建立小根堆
          if cur + 1 < n and heap[cur] > heap[cur + 1]:
              cur += 1  # cur为左右子节点最小值
          if heap[cur] >= temp:  # temp比左右子节点都小时结束
              break
          heap[(cur + 1) // 2 - 1] = heap[cur]
          cur = (cur + 1) * 2 - 1
      heap[(cur + 1) // 2 - 1] = temp
      return heap
  
  
  class ScaleSort:
      def sortElement(self, A, n, k):
          # write code here
          heap = A[:k + 1]  # 这里用了heap，空间复杂度不是O(1)
          for i in range((k - 1) // 2, -1, -1):  # 初始建堆，只需建前k+1个数的小顶堆，因为最小的数一定在前k+1个数里
              heap = adjust(heap, i, k + 1)
          for i in range(k, n - 1):  # 每次将堆顶的数去除，将A下一个数放在堆顶，调整为小顶堆
              A[i - k] = heap[0]
              heap[0] = A[i + 1]
              adjust(heap, 0, k + 1)
          for i in range(k + 1):  # A除了前面排好序的部分，其余已经全在堆中，开始只对堆操作，不向堆加入新值
              heap[0], heap[-1] = heap[-1], heap[0]
              A[n - k + i - 1] = heap.pop(-1)
              adjust(heap, 0, k - i)
          return A
  ```

+ 被排序数只有0，1，2，只需设置最左侧为0区，最右侧为2区，交换即可，$O(n)$时间复杂度。注意python的for迭代器不允许改变循环变量，需要改变时应用while。

  ```python
  class ThreeColor:
      def sortThreeColor(self, A, n):
          # write code here
          cur0 = 0
          cur2 = n - 1
          i = 0
          while i < n:
              if A[i] == 0:
                  A[cur0], A[i] = A[i], A[cur0]
                  cur0 += 1
              elif A[i] == 2:
                  A[cur2], A[i] = A[i], A[cur2]
                  cur2 -= 1
                  i -= 1
              i += 1
              if i < cur0 or i > cur2:
                  break
          return A
  ```

+ 给定数组，如果排序后，需要排序的最短子数组长度是多少。只需要找到需要移动的最左数和最右数。对于最右数，如果需要移动，一定是其左边部分的最大值比这个数更大，最左数同理。$O(n)$时间复杂度。

  ```python
  class Subsequence:
      def shortestSubsequence(self, A, n):
          # write code here
          if not A:
              return 0
          maxA, minA = A[0], A[-1]
          maxIndex, minIndex = 0, n - 1
          left, right = 1, 0  # 防止没有需要排序的情况
          for i in range(n):
              if A[i] > maxA:
                  maxA = A[i]
              elif A[i] < maxA:
                  right = i
          for i in range(n - 1, -1, -1):
              if A[i] < minA:
                  minA = A[i]
              elif A[i] > minA:
                  left = i
          return right - left + 1
  ```

+ 给定一个数组，返回排序后相邻元素的最大差值。利用计数排序思想，但不是将桶数量设置为max-min个，而是设置为数组长度个。对于n个数，将max-min范围划分为n个区间，不考虑最大值max，则n-1个数放进去必有至少一个空桶。最大差值即空桶两侧最值的差。$O(n)$时间复杂度。注意`//`为向下取整而不是四舍五入，同`int()`，乘法比除法保险。

  ```python
  class Gap:
      def maxGap(self, A, n):
          # write code here
          maxA, minA = max(A), min(A)
          bins = [[] for _ in range(n + 1)]
          for i in A:
              bins[(i - minA) * n // (maxA - minA)].append(i)  # 实际为int((i - minA) / ((maxA - minA) / n))，改写为乘法不会出错
          res = resLeft = 0
          for i in range(n + 1):
              if bins[i]:
                  resRight = min(bins[i])
                  res = max(resRight - resLeft, res)
                  resLeft = max(bins[i])
          return res
  ```

## 数组

### 判断数组是否有重复值

+ 题目：已知n个数，全部在0-n之间，有一些数有重复，找出任意一个重复的数。

+ 思路：
  + 哈希或字典，时间复杂度$O(n)$，空间复杂度$O(n)$。
  + 由于全部在0-n之间，从第i位开始，m=A[i]，如果i=m，则这个数放到了正确位置上，i+=1。否则将m和第m位比较，如果不同，交换两者。如果相同，则找到重复值。时间复杂度$O(n)$，空间复杂度$O(1)$。
  + 由于全部在0-n之间，遍历一遍，对于A里每一个数m，令A[m%n]+=n，这样遇到第一个大于等于n的数就是重复的数。时间复杂度$O(n)$，空间复杂度$O(1)$。
  + 如果不允许修改数组：
    + 省时间的方法为在上述方法基础上增加一个辅助数组。时间复杂度$O(n)$，空间复杂度$O(n)$。
    + 省空间的方法为不断二分查找，二分的条件是值小于还是大于n/2，阈值不断减半，每次都选值多的那一半（原理为1-4中如果没有重复，最多4个数字）。时间复杂度$O(n\log(n))$，空间复杂度$O(1)$。
  
+ 题解

  ```python
  class Solution:
      # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]
      # 函数返回True/False
      def duplicate(self, numbers, duplication):
          # write code here
          n = len(numbers)
          for m in numbers:
              realm = m % n
              if numbers[realm] >= n:
                  duplication[0] = realm
                  return True
              else:
                  numbers[realm] += n
          return False
  ```

### 二维数组中查找数

+ 题目：给定矩阵，每行从左到右、每列从上到下都是递增的，问数k在不在矩阵中。

+ 思路：从右上角开始找即可，每次比大小都能排除下面或左面的数，并将指针左移或下移，$O(m+n)$复杂度。

+ 题解

  ```python
  class Finder:
      def findX(self, mat, n, m, x):
          # write code here
          if not mat:
              return False
          curx, cury = 0, m - 1
          while 1:
              if x == mat[curx][cury]:
                  return True
              elif x > mat[curx][cury]:
                  if curx == n - 1:
                      return False
                  curx += 1
              elif x < mat[curx][cury]:
                  if cury == 0:
                      return False
                  cury -= 1
  ```

### 字符替换

+ 题目：将数组里"1"替换为"123"。
+ 思路：显然数组会变大，正向遍历并替换会出现需要移动后续元素，时间复杂度$O(n^2)$。最优解为正向遍历一遍统计有几个1需要替换，扩大数组空间，反向遍历，填充。时间复杂度$O(n)$。

### 包含min函数的栈

+ 题目：实现一个栈，包含pop、push、top和min函数。其中min返回栈的最小值。

+ 思路：使用一个辅助栈，记录当前栈的最小值。

+ 题解

    ```python
    class Solution:
        def __init__(self):
            self.stack = []
            self.min_stack = []
            
        def push(self, node):
            # write code here
            self.stack.append(node)
            if not self.min_stack or node < self.min_stack[-1]:
                self.min_stack.append(node)
            else:
                self.min_stack.append(self.min_stack[-1])
        def pop(self):
            # write code here
            self.min_stack.pop(-1)
            return self.stack.pop(-1)
        def top(self):
            # write code here
            return self.stack[-1]
        def min(self):
            # write code here
            return self.min_stack[-1
    ```

### 把数组排成最小的数

+ 题目：给定一个数组，将数组里元素排列后直接连起来，使得最后连起来的大数字最小。
+ 思路：显然要对数组排序，但是直接排序时，[13,2]会构成213，实际上132才是最小的。将数字转换为字符串，比大小改为比两数拼接后谁小。

### 找数组中数字k出现的次数

+ 思路：二分查找，分别找到第一次和最后一次出现的下标，求个数。

+ 题解

  ```python
  def get_first_k(data, k):
      start, end = 0, len(data) - 1
      while 1:
          mid = (start + end) // 2
          if data[mid] < k:
              start = mid + 1
          elif data[mid] > k:
              end = mid - 1
          else:
              if mid == 0 or data[mid - 1] != k:
                  return mid
              end = mid - 1
          if start > end:
              return -1
  
  def get_last_k(data, k):
      start, end = 0, len(data) - 1
      while 1:
          mid = (start + end) // 2
          if data[mid] < k:
              start = mid + 1
          elif data[mid] > k:
              end = mid - 1
          else:
              if mid == len(data) - 1 or data[mid + 1] != k:
                  return mid
              start = mid + 1
          if start > end:
              return -1
  
  class Solution:
      def GetNumberOfK(self, data, k):
          # write code here
          if not data:
              return 0
  
          start = get_first_k(data, k)
          if start == -1:
              return 0
          end = get_last_k(data, k)
          return end - start + 1
  ```

## 字符串

### 判断两二叉树（字符串）是否为包含关系

+ 思路：

  + 暴力匹配，$O(m*n)$时间复杂度。

  + 将树深度优先遍历变为数组，较长的为长度为m的主字符串M，较短的为长度为n的模式串P。

    + 暴力匹配，以主字符串M每一个字符作为开头，匹配模式串P，$O(m*n)$时间复杂度。

    + 使用==KMP算法==。

      + 定义`"abcab"`的前缀集合为`["a","ab","abc","abca"]`，后缀为`["b","ab","cab","bcab"]`，可以看到前后缀不包括字符串自己。

      + 设置一个部分匹配表`PMT`，长度和模式串P相同。其中`PMT[i]`即为对模式串P的子串`P[:i+1]`的前缀集合和后缀集合的交集中，最长项长度。如`i=3`时，子串`P[:4]="abca"`中，前后缀集合的交集为`["a"]`，最长项长度为1，`PMT[3]=1`。此步骤为$O(n^2)$时间复杂度，通过优化可以变为$O(n)$时间复杂度。

      + 匹配时，如果`i`和`j`分别为主字符串`M`和模式串`P`的指针，假设在主字符串`M[i]`处、模式字符串`P[j]`处失配，那么已经匹配好的长度是`j`位，且**在这匹配好的`j`位字符中**，前`PMT[j-1]`和后`PMT[j-1]`的字符是相同的（这是`PMT`的定义，如下面左图的两个灰色部分），只需将主字符串的后`PMT[j-1]`的字符作为下一次比较时已经匹配好的部分，即将模式串`P`的指针设为`j=PMT[j-1]`，继续将`P[j]`和`M[i]`匹配即可。此步骤为$O(m)$时间复杂度。

        ![image.png](https://i.loli.net/2020/02/28/twjyObA3vIrWNc1.png)

      + 优化`PMT`生成算法如下：如果对于模式串`P`的一个子串`P[:x]`，有两个指针`x`和`now`，如图。前`now-1`位和后`now-1`位已经相同，即`PMT[x-1] = now-1`，那么对于末尾加了一个字符的子串`P[:x+1]`的`PMT[x]`，如果`P[now]==P[x]`，则`PMT[x]=PMT[x-1]+1`。但如果`P[now]!=P[x]`，需要将`now`缩小，具体缩小到子串`P[:x-2]`对应的`PMT`值`PMT[P[x-1]]`，原因如下。此步骤$O(n)$时间复杂度。

        ![image.png](https://i.loli.net/2020/02/28/elAkPm7oEctuswf.png)

      + 总步骤为$O(M+N)$时间复杂度。

+ 题解

  ```python
  def generate_str(tree, treestr):  # 从树生成字符串。注意这里必须用符号标明节点为空，否则本题可能出现：大树虽然包含小树，但大树的小数部分还有子节点
      if not tree:
          return treestr + '#!'
      treestr += str(tree.val) + '!'
      treestr = generate_str(tree.left, treestr)
      treestr = generate_str(tree.right, treestr)
      return treestr
  
  
  class IdenticalTree:
      def chkIdentical(self, A, B):
          # write code here
          A_str = ""
          B_str = ""
          A_str = generate_str(A, A_str)
          B_str = generate_str(B, B_str)
          if len(A_str) > len(B_str):  # 主字符串M，模式串P
              P, M = B_str, A_str
          else:
              M, P = B_str, A_str
  		
          # 生成PMT
          PMT = [0 for _ in range(len(P))]
          now, x = 0, 1  # x从1开始
          while x < len(P):
              if P[now] == P[x]:
                  PMT[x] = PMT[x - 1] + 1
                  x += 1
                  now += 1
              elif not now:
                  PMT[x] = 0
                  x += 1
              else:
                  now = PMT[now - 1]
          print(PMT)
          
          # KMP算法
          i = 0
          j = 0
          while i < len(M):
              if j == 0 and M[i] != P[j]:  # 模式串P第一个字符就匹配不成功，主字符串向后走
                  i += 1
              elif M[i] == P[j]:  # 匹配成功
                  i += 1
                  j += 1
              else:  # 匹配一半失配，调整j位置
                  j = PMT[j - 1]
              if j == len(P):
                  return True
          return False
  ```

+ 知识点：树变为字符串时，建议设置'#!'标明空节点，'!'分割每个值。这样不会导致1和10与11和0的问题，也能避免子树包含但子树还有子节点问题。

### 判断两单词是否为乱序

+ 思路：建立哈希表（字典），长度不同一定不为乱序。

+ 题解

  ```python
  class Transform:
      def chkTransform(self, A, lena, B, lenb):
          # write code here
          if lena != lenb:
              return False
          dicA = {}
          for i in A:
              dicA[i] = dicA.get(i, 0) + 1
          for i in B:
              if i not in dicA.keys():
                  return False
              dicA[i] -= 1
              if dicA[i] < 0:
                  return False
          return True
  ```

###判断两单词是否为旋转词

+ 题目：如果str1前面任意长度挪到后面得到str2，则互为旋转词。如abc和bca和cab。

+ 思路：将str1和str1拼接为str0，可以发现str0中一定包含str1的所有旋转词。注意两字符串长度相同为前提。判断包含时，有要求复杂度条件下，使用KMP算法。

+ 题解

  ```python
  return lena == lenb and B in A+A
  ```

### 括号匹配

+ 思路：设置一个变量，遇到左括号自增，遇到右括号自减。每次自减如果小于0则不匹配。结束后如果大于0则不匹配。多个括号的题需要多个变量。这里其实就是用变量代替栈。

+ 题解
  
  ```python
  class Parenthesis:
      def chkParenthesis(self, A, n):
          # write code here
          num = 0
          for i in A:
              if i is '(':
                  num += 1
              elif i is ')':
                  num -= 1
                  if num < 0:
                      return False
          if num > 0:
              return False
          return True
  ```

### ==滑动窗口==

见[3. 无重复字符的最长子串]。

### 正则匹配

+ 题目：实现一个有`.`、`*`的正则。==难题。==

+ 题解

    ```python
    class Solution:
        # s, pattern都是字符串
        def match(self, s, pattern):
        # write code here
            # 如果两者都为空，则匹配成功
            if (len(s) == 0 and len(pattern) == 0):
                return True
            # 如果模式为空，字符串不为空，则匹配不成功
            if (len(s) > 0 and len(pattern) == 0):
                return False
            
            # 如果第二个为*
            if len(pattern) > 1 and pattern[1] == '*':
                if s and (pattern[0] == '.' or s[0] == pattern[0]):  # 第一个匹配成功
                    f1 = self.match(s[1:], pattern)  # *指出现多次
                    f2 = self.match(s[1:], pattern[2:])  # *指出现1次
                    f3 = self.match(s, pattern[2:])  # *指出现0次
                    if f1 or f2 or f3:
                        return True
                    else:
                        return False
                else:  # 第一个匹配不成功，此时*指出现0次
                    return self.match(s, pattern[2:])
            # 第二个不为*且第一个匹配上
            elif s and (pattern[0] == '.' or s[0] == pattern[0]):
                    return self.match(s[1:], pattern[1:])
            # 第二个不为*且第一个没有匹配上
            else:
                return False
    ```

### 判断字符串是否为小数

+ 思路：`[+|-]A[.[B]][e|E[+|-]C]`或`.B[e|E[+|-]C]`，合法的边界如1.2e-5，.3，1.，，非法边界如1e1.2，12e，1a2。

+ 题解

    ```python
    class Solution:
        # s字符串
        def isNumeric(self, s):
            # write code here
            # [+|-]A[.[B]][e|E[+|-]C]|.B[e|E[+|-]C]
            status = 0  # 整数部分A等待符号
            S = s
            for s in S:
                if s == '.':
                    if status <= 2:
                        status = 3  # 输入小数点，等待小数
                    else:
                        return False
                elif s == '+' or s == '-':
                    if status == 0:
                        status = 1  # 输入符号，等待整数部分数字
                    elif status == 5:
                        status = 6  # 输入e后的符号，等待数字
                    else:
                        return False
                elif s >= '0' and s <= '9':
                    if status <= 2:
                        status = 2  # 继续等待整数部分数字
                    elif status == 3 or status == 4:
                        status = 4  # 输入小数，继续等待小数
                    elif status == 5 or status == 6 or status == 7:
                        status = 7  # 输入e后的数字
                elif s == 'e' or s == 'E':
                    if status <= 4 and status != 1:
                        status = 5  # e或E部分
                    else:
                        return False
                else:
                    return False
            if status == 0 or status == 1 or status == 5:
                return False
            return True
    ```

## 链表

### 链表分化

+ 题目：给定head和val，返回一个链表，要求将小于等于val的放在链表前部分，大于val的放在后部分。

+ 思路：设置两个子链表，分别保存小于等于val、大于val的节点，最后拼接。

+ 题解

  ```python
  class Divide:
      def listDivide(self, head, val):
          # write code here
          smaller = greater = None
          smaller_cur = greater_cur = None
          cur = head
          while cur:
              if cur.val <= val:
                  if not smaller:
                      smaller = cur
                      smaller_cur = cur
                  else:
                      smaller_cur.next = cur
                      smaller_cur = cur
              else:
                  if not greater:
                      greater = cur
                      greater_cur = cur
                  else:
                      greater_cur.next = cur
                      greater_cur = cur
              cur = cur.next
          head = None
          if smaller:
              smaller_cur.next = None  # 重点
              head = smaller
              cur_head = smaller_cur
          if greater:
              greater_cur.next = None  # 重点
              if not head:
                  head = greater
              else:
                  cur_head.next = greater
          return head
  ```

### 链表找中间值，并从中间值开始操作

+ 思路：
  + 暴力法：数到尾部，总数除以2，重新遍历。
  + 两个指针：一个跑2步一个跑1步，停止条件为：快指针.next.next为空，此时low指向奇数中间；快指针.next.next.next为空，此时low指向偶数的中间的第一个数。（原理可以自己画一个奇数一个偶数去数）

### 判断链表是否有环

+ 思路：
  + 哈希表
  + 两个指针：一个跑2步一个跑1步，有环总会相遇。

### 判断两无环链表是否相交

+ 思路：相交后，一定完全相同，不会再分开。只需两个链表都走到头，判断最后一个节点是否相同。

### 链表反转

+ 思路：边遍历边反转

+ 题解

  ```python
  class Solution:
      # 返回ListNode
      def ReverseList(self, pHead):
          # write code here
          if not pHead:
              return None
          if not pHead.next:
              return pHead
          next = pHead.next
          flag = 0
          while next:
              if next.next:
                  next2 = next.next
              else:
                  next2 = None
              next.next = pHead
              if not flag:
                  pHead.next = None
                  flag = 1
  
              pHead = next
              next = next2
          return pHead
  ```

### 链表倒数第k个节点

+ 思路：快慢指针。

+ 题解

  ```python
  class Solution:
      def FindKthToTail(self, head, k):
          # write code here
          fast = head
          low = None
          while fast:
              fast = fast.next
              if not low:
                  k -= 1
                  if not k:
                      low = head
              else:
                  low = low.next
          return low
  ```

### 删除节点

+ 题目：给定节点，$O(1)$时间复杂的内删除该节点。
+ 思路：将其后一个节点信息复制到该节点上，删除后一个节点。

### 找到链表中环的入口

+ 思路：首先判定有没有环，采用快慢两个指针，有环则一定会相遇。如果有环，为了确定入口，需要两个指针，一个指针先走x步，x为环的节点数。为了确定环的节点数，可以在第一步确定有环后，快指针不动，慢指针继续走，直到两指针再次相遇。

+ ```python
    class Solution:
        def EntryNodeOfLoop(self, pHead):
            # write code here
            if not pHead:
                return None
    
            fast_node = slow_node = pHead
            len_loop = 1
            while 1:
                if fast_node.next and fast_node.next.next:
                    fast_node = fast_node.next.next
                    slow_node = slow_node.next
                    if fast_node == slow_node:  # 确定有环，开始找环长度
                        slow_node = slow_node.next
                        while fast_node != slow_node:
                            slow_node = slow_node.next
                            len_loop += 1
                        break
                else:
                    return None
    
            fast_node = slow_node = pHead  # 根据环长度，找环开头
            for _ in range(len_loop):
                fast_node = fast_node.next
            while fast_node != slow_node:
                fast_node = fast_node.next
                slow_node = slow_node.next
            return fast_node
    
    ```

### 复制复杂链表

+ 题目：该链表除了next，还有一个指向其他节点的随机指针。显然，难点在于怎么复制这个指针。

+ 思路：在原链表上，每个节点后复制该节点，这样很轻易地找到随机指针指向的节点。最后拆分这个链表。

+ ```python
    class Solution:
        # 返回 RandomListNode
        def Clone(self, pHead):
            # write code here
            if not pHead:
                return None
    
            cur = pHead
            while cur:
                next = cur.next
                cur.next = RandomListNode(cur.label)
                cur.next.next = next
                cur = next
    
            cur = pHead
            while cur:
                if cur.random:
                    cur.next.random = cur.random.next
                cur = cur.next.next
    
            pHead_new = pHead.next
            cur = pHead_new
            while cur.next:
                cur.next = cur.next.next
                cur = cur.next
            pHead.next = None
            return pHead_new
    ```

### 找两个链表第一个公共节点

+ 思路：如果有公共节点，两个链表最后会合并。首先求出两个链表长度，长的先走x步，x为两链表长度差。此时同时遍历两个链表，第一个相同点就是所求。

+ 题解

    ```python
    class Solution:
        def FindFirstCommonNode(self, pHead1, pHead2):
            # write code here
            len1 = len2 = 0
            cur = pHead1
            while cur:
                cur = cur.next
                len1 += 1
            cur = pHead2
            while cur:
                cur = cur.next
                len2 += 1
            if len1 > len2:
                for _ in range(len1 - len2):
                    pHead1 = pHead1.next
            elif len2 > len1:
                for _ in range(len2 - len1):
                    pHead2 = pHead2.next
            while pHead1 and pHead2:
                if pHead1 == pHead2:
                    return pHead1
                pHead1 = pHead1.next
                pHead2 = pHead2.next
            return Non
    ```

## 二叉树

### 递归DFS

+ 思路：DFS

+ 题解

  ```python
  def front(cur, result):
      if cur:
          result[0].append(cur.val)
      if cur.left:
          front(cur.left, result)
      if cur.right:
          front(cur.right, result)
      
  def middle(cur, result):
      if cur.left:
          middle(cur.left, result)
      if cur:
          result[1].append(cur.val)
      if cur.right:
          middle(cur.right, result)
      
  def back(cur, result):
      if cur.left:
          back(cur.left, result)
      if cur.right:
          back(cur.right, result)
      if cur:
          result[2].append(cur.val)
  
  class TreeToSequence:
      def convert(self, root):
          # write code here
          result = [[] for _ in range(3)]
          front(root, result)
          middle(root, result)
          back(root, result)
          return result
  ```

### ==非递归DFS==

+ 思路：DFS，用栈。

  + 前序时为每次从栈顶弹出一个，先输出，后将**右、左**节点入栈（这样左节点会先弹出）。
  + 中序为对于每个cur节点，**如果cur存在，入栈，cur变为其左节点，否则栈顶弹出cur，输出，cur变为其右节点**。
  + 后序为，每次从栈顶弹出一个，**压入temp栈用于倒着输出**，后将左、右节点入栈（这样temp中，中间的最后输出，然后是右，最先输出的是左），直至栈空，输出temp栈。

+ 题解
  
  ```python
  class TreeToSequence:
      def convert(self, root):
          # write code here
          result = [[] for _ in range(3)]
          
          # 前序，中左右
          stack = [root]
          while stack:
              cur = stack.pop(-1)
              result[0].append(cur.val)
              if cur.right:  # 先压右后压左，才能在弹出时先弹左后弹右
                  stack.append(cur.right)
              if cur.left:
                  stack.append(cur.left)
          
          # 中序，左中右
          cur = root
          stack = []
          while stack or cur:
              if cur:
                  stack.append(cur)
                  cur = cur.left
              else:
                  cur = stack.pop(-1)
                  result[1].append(cur.val)
                  cur = cur.right
          
          # 后序，左右中，temp中就为中右左，实际修改前序过程即可
          stack = [root]
          temp = []
          while stack:
              temp.append(stack[-1].val)
              cur = stack.pop(-1)
              if cur.left:
                  stack.append(cur.left)
              if cur.right:
                  stack.append(cur.right)
          for i in range(len(temp) - 1, -1, -1):
              result[2].append(temp[i])
          return result
  ```

### 二叉树重建

+ 题目：根据前序和中序重建二叉树。

+ 思路：我们知道，前序为中左右，中序为左中右。前序第一个一定为根节点，在中序中找到根节点，左侧的就为其左子树，右侧为其右子树。根据左子树的节点数m，可知在前序中根节点后m个都为左子树，这样就得到了其左子树的前序和中序。同理，可得右子树的前序和中序，递归即可。

+ 题解

  ```python
  def gen(cur, left_tin, left_pre, right_tin, right_pre):
      if left_pre:  # 构造cur的左子树节点的：左子树中序、左子树前序、右子树中序、右子树前序
          left = TreeNode(left_pre[0])
          cur.left = left
          left_left_tin = left_tin[:left_tin.index(left_pre[0])]
          left_left_pre = left_pre[1: 1 + len(left_left_tin)]
          left_right_tin = left_tin[left_tin.index(left_pre[0]) + 1:]
          left_right_pre = left_pre[1 + len(left_left_tin):]
          gen(left, left_left_tin, left_left_pre, left_right_tin, left_right_pre)
  
      if right_pre:  # 构造cur的右子树节点的：左子树中序、左子树前序、右子树中序、右子树前序
          right = TreeNode(right_pre[0])
          cur.right = right
          right_left_tin = right_tin[:right_tin.index(right_pre[0])]
          right_left_pre = right_pre[1: 1 + len(right_left_tin)]
          right_right_tin = right_tin[right_tin.index(right_pre[0]) + 1:]
          right_right_pre = right_pre[1 + len(right_left_tin):]
          gen(right, right_left_tin, right_left_pre, right_right_tin, right_right_pre)
  
  
  class Solution:
      # 返回构造的TreeNode根节点
      def reConstructBinaryTree(self, pre, tin):
          # write code here
          if not pre:
              return None
  
          root = TreeNode(pre[0])
          left_tin = tin[:tin.index(pre[0])]
          left_pre = pre[1: 1 + len(left_tin)]
          right_tin = tin[tin.index(pre[0]) + 1:]
          right_pre = pre[1 + len(left_tin):]
          gen(root, left_tin, left_pre, right_tin, right_pre)
          return root
  ```

+ 知识点：python中，函数参数为数组或类，无需返回即可修改内容。

### 按层BFS

+ 题目：返回二叉树，要求广度优先遍历`BFS`，且按层输出，一行一个子list，如`[[0],[1,2],[3,4,5,6]`，难点为换行。

+ 思路：BFS要求建立队列，每次`pop`头节点，将该节点的左右子节点`append`。对于按层输出，设置`last`节点，标记每层最后一个节点，当`cur`到`last`节点后，进入新一层，更新last。

+ 题解

  ```python
  class TreePrinter:
      def printTree(self, root):
          # write code here
          if not root:
              return
          treeList = [root]
          last = treeList[-1]  # 指示每层最后一个节点
          resList = [[]]
          while treeList:
              cur = treeList.pop(0)
              resList[-1].append(cur.val)
              if cur.left:
                  treeList.append(cur.left)
              if cur.right:
                  treeList.append(cur.right)
              if cur == last and treeList:
                  resList.append([])
                  last = treeList[-1]
          return resList
  ```

### 二叉树下一个节点

+ 题目：给定一颗二叉树的一个节点，有指向父节点的指针。要求找到中序遍历下一个节点。

+ 思路：中序遍历为左中右，给定一个节点作为中，如果有右子节点，先找其右子树的最左，右子树没有左时，找右子节点即可。如果没有右子节点，找父节点，看当前节点是左孩子还是右孩子。如果是左孩子，父节点就是下一个，如果是右孩子，继续向上找。直至父节点不存在，则该节点没有下一个节点。

+ 题解

  ```python
  class Solution:
      def GetNext(self, pNode):
          # write code here
          if pNode.right:
              pNode = pNode.right
              while pNode.left:
                  pNode = pNode.left
              return pNode
          else:
              while 1:
                  if not pNode.next:  # 父节点
                      return None
                  prev = pNode.next
                  if prev.left and prev.left == pNode:
                      return prev
                  elif prev.right and prev.right == pNode:
                      pNode = prev
  ```

### 平衡二叉树判断

+ 题目：平衡二叉树每个结点的左子树和右子树高度差不超过1，典型平衡二叉树如：三层，除头节点外都只有左子节点。

+ 思路：对于每个节点，记录左右子树高度，同时判断左右子树是否为平衡二叉树。

+ 题解

  ```python
  def checkCur(cur, h):
      if not cur or (cur and cur.val == '#'):
          return h - 1, True
      else:
          lh, isBalanced = checkCur(cur.left, h + 1)  # cur.left当前处于第h+1层
          if not isBalanced:
              return h, isBalanced
          rh, isBalanced = checkCur(cur.right, h + 1)
          if not isBalanced or abs(lh - rh) > 1:
              isBalanced = False
              return h, isBalanced
          return max(lh, rh), isBalanced
  
  class CheckBalance:
      def check(self, root):
          # write code here
          h, isBalanced = checkCur(root, 0)
          return isBalanced
  ```

### 满二叉树判断

+ 题目：满二叉树的每个层都是满的，即每个结点，都左子树深度=右子树深度。

### 完全二叉树判断

+ 题目：完全二叉树的每个结点，都有左子树深度=右子树深度或左子树深度=右子树深度+1。

+ 思路：对于每个节点，记录左右子树高度，同时判断左右子树是否为完全二叉树。

+ 题解

  ```python
  def checkCur(cur, h):
      if not cur or (cur and cur.val == '#'):
          return h - 1, True
      else:
          lh, isFull = checkCur(cur.left, h + 1)  # cur.left当前处于第h+1层
          if not isFull:
              return h, isFull
          rh, isFull = checkCur(cur.right, h + 1)
          if not isFull or lh - rh > 1 or lh - rh < 0:
              isFull = False
              return h, isFull
          return max(lh, rh), isFull
  
  class CheckCompletion:
      def chk(self, root):
          # write code here
          h, isFull = checkCur(root, 0)
          return isFull
  ```

### 搜索二叉树（二叉查找树、二叉排序数）

+ 题目：搜索二叉树的每个节点，比其所有左子树都大，比其所有右子树都小（子树可以为空）。搜索二叉树按照中序遍历，一定升序。
+ 思路：非递归中序遍历，有序则为搜索二叉树。

### 根据后序遍历判断搜索二叉树

+ 题目：给定后序遍历，判断是否为二叉搜索树。

+ 思路：后序，最后一个为根节点，遍历前面部分，第一个比根节点大的为右子树开头，左侧为左子树。递归结束条件为，找到右子树开头后，后面有比根节点小的，则不是搜索二叉树。

+ 题解

    ```python
    def check(sequence):
        if not sequence or len(sequence) == 1:
            return True
        cur = sequence.pop(-1)
    
        mid = -1
        for i in range(len(sequence)):
            if mid == -1 and sequence[i] > cur:
                mid = i
            elif mid != -1 and sequence[i] < cur:
                return False
        if mid == -1:
            mid = len(sequence) - 1
        flag = check(sequence[:mid])
        if not flag:
            return flag
        flag = check(sequence[mid:])
        return flag
    
    class Solution:
        def VerifySquenceOfBST(self, sequence):
            # write code here
            if not sequence:
                return False
    
            flag = check(sequence)
            return flag
    ```

### 搜索二叉树变双向链表

+ 题目：不允许另开数组或节点。难题。

+ 思路：递归，找到每个节点x的左子树的最右节点y（即左子树最大节点），和x节点双向相连，显然y节点是小于x节点的最大节点。同理，将节点x的右子树的最左节点y（即右子树的最小节点），和x节点双向相连，显然y节点是大于x节点的最小节点。

+ 题解

    ```python
    class Solution:
        def Convert(self, pRootOfTree):
            # write code here
            if not pRootOfTree or (not pRootOfTree.left and not pRootOfTree.right):
                return pRootOfTree
            
            # 处理左子树
            self.Convert(pRootOfTree.left)
            left = pRootOfTree.left
            
            # 连接根与左子树最大结点
            if left:
                while(left.right):
                    left = left.right
                pRootOfTree.left, left.right = left, pRootOfTree
            
            # 处理右子树
            self.Convert(pRootOfTree.right)
            right = pRootOfTree.right
            
            # 连接根与右子树最小结点
            if right:
                while(right.left):
                    right = right.left
                pRootOfTree.right, right.left = right, pRootOfTree
                 
            while(pRootOfTree.left):  # 找到链表头节点
                pRootOfTree=pRootOfTree.left
            return pRootOfTree
    ```

### 判断二叉树是否对称

+ 思路：递归判断左子树和右子树。

+ 题解

    ```python
    def isSymmetrical(self, pRoot):
            # write code here
            def is_same(p1, p2):
                if not p1 and not p2:
                    return True
                if (p1 and p2) and p1.val==p2.val:
                    return is_same(p1.left, p2.right) and is_same(p1.right, p2.left)
                return False
            if not pRoot:
                return True
            return is_same(pRoot.left,pRoot.right)
    ```

## ==动态规划==

+ 实质为空间换时间，避免重复计算。主要过程为：**构造dp状态矩阵，想出状态转移方程**，考虑初始化。

### 换零钱

+ 题目：有n种面值的货币，构成aim元钱，有几种方法。

+ 思路：

  + 暴力法
  + 记忆搜索法
  + dp法：设置n行aim+1列的矩阵，第i行第j列表示使用0-i种货币时，表示j元钱的方法数。

+ ```python
  class Exchange:
      def countWays(self, penny, n, aim):
          # write code here
          # 初始化第一行和第一列
          dp = [[0 for _ in range(aim + 1)] for _ in range(n)]
          for i in range(n):
              dp[i][0] = 1
          for i in range(aim + 1):
              if i % penny[0] == 0:
                  dp[0][i] = 1
  
          for i in range(1, n):  # 由于dp[i][j]依赖于上侧的dp[i-1][j]和左侧的dp[i][j-1]，故遍历时候先行后列或先列后行均可，但一定要从左上到右下
              for j in range(1, aim + 1):
                  dp[i][j] = dp[i - 1][j] + dp[i][j - penny[i]] if j - penny[i] >= 0 else  dp[i - 1][j]  # 状态转移方程：要么不用penny[i]构成j元，要么用一张penny[i]构成j-penny[i]元。两张及以上的情况已经在一张里
          return dp[-1][-1]
  ```

### 上台阶

+ 题目：一次只能走一步或两步，共n级台阶，有几种上法。

+ 思路：动态规划，只需建立一维dp，dp[i]表示走到第i阶的方法，$dp[i]=dp[i - 1]+dp[i-2]$，即上一级台阶或两级台阶。

+ ```python
  class GoUpstairs:
      def countWays(self, n):
          # write code here
          dp = [0 for _ in range(n + 1)]
          dp[0] = 1
          dp[1] = 1
          for i in range(2, n + 1):
              dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007
          return dp[-1]
  ```

### 走迷宫

+ 题目：矩阵每个位置都有数字，从左上角走到右下角，只能向右或向下走，求路径路过的数字之和最小值。

+ 思路：动态规划，每走到一个位置，都有两个来的方向，最小值作为当前最优解。

+ ```python
  class MinimumPath:
      def getMin(self, mmap, n, m):
          # write code here
          dp = [[0 for _ in range(m)] for _ in range(n)]
          dp[0][0] = mmap[0][0]
          for i in range(m):
              dp[0][i] = mmap[0][i] + dp[0][i - 1]
          for i in range(n):
              dp[i][0] = mmap[i][0] + dp[i - 1][0]
  
          for i in range(1, n):
              for j in range(1, m):
                  dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + mmap[i][j]
          return dp[-1][-1]
  ```

### 最长递增子序列

+ 题目：返回最长递增子序列长度，子序列不需要连续，递增指严格递增，没有等号。

+ 思路：动态规划，dp[i]表示**必须以A[i]结尾的最长子序列**，其以来源为i之前的所有元素结尾的最长子序列长度加一，或直接为1。

+ ```python
  class LongestIncreasingSubsequence:
      def getLIS(self, A, n):
          # write code here
          dp = [0 for _ in range(n)]
          dp[0] = 1
          for i in range(1, n):
              maxdp = 0
              for j in range(i - 1, -1, -1):
                  if A[j] < A[i] and dp[j] > maxdp:
                      maxdp = dp[j]
              dp[i] = maxdp + 1
          return max(dp)
  ```

### 最长公共子序列

+ 题目：返回两个array的最长公共子序列长度，子序列不需要连续。

+ 思路：动态规划，`dp[i][j]`表示`array1[:i+1]`和`array2[:j+1]`的最长公共子序列长度，其来源包括`dp[i-1][j]`、`dp[i][j-1]`、`dp[i-1][j-1]+1`三种

+ ```python
  class LCS:
      def findLCS(self, A, n, B, m):
          # write code here
          dp = [[0 for _ in range(n)] for _ in range(m)]
          for i in range(m):
              if A[0] in B[:i + 1]:
                  dp[i][0] = 1
          for i in range(n):
              if B[0] in A[:i + 1]:
                  dp[0][i] = 1
  
          for i in range(1, m):
              for j in range(1, n):
                  if A[j] == B[i]:
                      dp[i][j] = dp[i - 1][j - 1] + 1
                  else:
                      dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
          return max(max(dp))
  ```

### 连续子树组的最大和

+ 题目：给定数组，有正数和负数，找其子数组的和的最大值。

+ 思路：动态规划，`dp[i]`表示以`array[i]`结尾的数组和的最大值。来源包括：如果`dp[i-1]`小于0，则为`array[i]`，否则为`dp[i-1]+array[i]`。

+ ```python
    class Solution:
        def FindGreatestSumOfSubArray(self, array):
            # write code here
            dp = [0 for _ in range(len(array))]
            dp[0] = array[0]
            for i in range(1, len(array)):
                if dp[i - 1] >= 0:
                    dp[i] = dp[i - 1] + array[i]
                else:
                    dp[i] = array[i]
            return max(dp)
    ```

### 01背包问题

+ 题目：物品有重量和价值，每个物品只能用一次，求使得背包不超过载重的最大价值。

+ 思路：动态规划，`dp[i][j]`**表示前0-i件物品，最大不超过j重量时的最大价值**，来源包括：不使用i件的`dp[i-1][j]`和使用i件的`dp[i-1][j-w[i]]+v[i]`

+ ```python
  class Backpack:
      def maxValue(self, w, v, n, cap):
          # write code here
          dp = [[0 for _ in range(cap + 1)] for _ in range(n)]
          for i in range(cap + 1):
              if i >= w[0]:
                  dp[0][i] = v[0]
  
          for i in range(1, n):
              for j in range(1, cap + 1):
                  if j - w[i] >= 0:
                      dp[i][j] = max(dp[i - 1][j - w[i]] + v[i], dp[i - 1][j])
                  else:
                      dp[i][j] = dp[i - 1][j]
          return max(max(dp))
  ```

### 最优编辑问题

+ 题目：给定两个字符串，长度为m和n，操作有插入、删除、替换，代价分别为c0、c1、c2，求字符串A变为字符串B的最小代价。

+ 思路：动态规划，构造(m+1)\*(n+1)的dp矩阵，`dp[i][j]`表示`A[:i]`和`B[:j]`的最优编辑（注意这里`dp[0][0]`表示`''`到`''`的最优编辑），可能的来源有4个，分别是：如果`A[i-1]=B[j-1]`则 `dp[i-1][j-1]`、或在`dp[i-1][j-1]`基础上替换最后一位、或在`dp[i-1][j]`基础上插入最后一位、或在`dp[i][j-1]`基础上删除最后一位

+ ```python
  class MinCost:
      def findMinCost(self, A, n, B, m, c0, c1, c2):
          # write code here
          dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]
          for i in range(1, m + 1):
              dp[0][i] = c0 * i
          for i in range(1, n + 1):
              dp[i][0] = c1 * i
          
          for i in range(1, n + 1):
              for j in range(1, m + 1):
                  if A[i - 1] == B[j - 1]:
                      dp[i][j] = dp[i - 1][j - 1]
                  else:
                      dp[i][j] = min(dp[i - 1][j - 1] + c2, dp[i - 1][j] + c1, dp[i][j - 1] + c0)
          return dp[-1][-1]
  ```

### 剪绳子

+ 题目：将长度为number的绳子剪成x（x>1）段，要求所有绳子长度的乘积最大。

+ 思路：动态规划。

    + ```python
        class Solution:
            def cutRope(self, number):
                # write code here
                if number == 0 or number == 1:
                    return 0
                elif number == 2:
                    return 1
                elif number == 3:
                    return 2
                dp = [0 for _ in range(number + 1)]
                dp[1] = 1  # 由于i=1，2，3时，不拆分比拆分的乘积更大，故单独考虑
                dp[2] = 2
                dp[3] = 3
                for i in range(4, number + 1):
                    dp[i] = max([dp[j] * dp[i - j] for j in range(1, i // 2 + 1)])
                return dp[number]
        ```

## 递归和循环

### 斐波那契数列

+ 题目：实现斐波那契数列，第0个为0，第1个为1，第2个为f(0)+f(1)。

+ 思路：循环代替递归。

+ 题解

  ```python
  class Solution:
      def Fibonacci(self, n):
          # write code here
          num1 = 0
          num2 = 1
          if n == 0:
              return 0
          elif n == 1:
              return 1
          n -= 1
          while n:
              res = num1 + num2
              num1 = num2
              num2 = res
              n -= 1
          return num2
  ```

### 全排列

+ 题目：给定字符串，字符串内只有大小写字母，可能有重复字母，返回这些字母的全排列。难题。

+ 思路：递归。

+ 题解

    ```python
    class Solution:
        def Permutation(self, ss):
            # write code here
            if not len(ss):
                return []
            if len(ss) == 1:
                return list(ss)
            charList = list(ss)
            charList.sort()
            pStr = []
            for i in range(len(charList)):
                if i > 0 and charList[i] == charList[i-1]:
                    continue
                others = self.Permutation(charList[:i]+charList[i+1:])  # 去掉作为开头的charList[i]，剩下部分作为剩余部分
                for other in others:
                    pStr.append(charList[i]+other)  # 以charList[i]开头
            return pStr
    ```

## 位运算

### 求一个数二进制的1个数

+ 题目：对于一个整数n，求二进制的1的个数。

+ 思路：n-1会将n最右侧的1变为0，其右侧的0都变为1。n&(n-1)即将最右侧1变为0。每一次操作消除一个1。对于负数，python没有位数概念，会死循环，需要将n&0xffffffff，限制n为32位二进制。

+ 题解

    ```python
    class Solution:
        def NumberOf1(self, n):
            # write code here
            res = 0
            n &= 0xffffffff
            while n:
                res += 1
                n = (n - 1) & n  # n-1一定是将n最右侧的1变为0，其右侧的0都变为1。按位与后，相当于把n最右侧的1变成0。每一次操作，消除一个1
            return res
    ```

+ 知识点：
    + 位运算比乘除法效率高很多，能通过左右移实现就不要用乘除法。
    + 小数的相等不能用`==`判断，存在精读问题，要用`abs(a-b)<error`或`math.close(a,b,rel_tol=1e-5)`。

## 新概念

### 丑数

+ 题目：定义只有2、3、5作为因子的数为丑数，1为第一个丑数，此后还有2，3，5，6，10等。求第1500个丑数。

+ 思路：找下一个丑数的方法：如果**ugly[t2]\*2**小于ugly最后一个数，t2自增。t3，t5同理，这样就找到了下一个丑数的三个候选值，取min作为下一个丑数。

+ ```python
  class Solution:
      def GetUglyNumber_Solution(self, index):
          # write code here
          if index == 1:
              return 1
          elif index < 1:
              return 0
          
          res = [1]
          t2 = t3 = t5 = 0
          for _ in range(index - 1):
              while res[t2] * 2 <= res[-1]:
                  t2 += 1
              while res[t3] * 3 <= res[-1]:
                  t3 += 1
              while res[t5] * 5 <= res[-1]:
                  t5 += 1
              res.append(min(res[t2] * 2, res[t3] * 3, res[t5] * 5))
          return res[-1]
  ```

### yield

+ 相当于一个迭代的返回值

+ ```
    def foo():
        print("starting...")
        while True:
            res = yield 4
            print("res:",res)
    g = foo() # 不运行foo
    print(next(g))  # 输出starting，返回4
    print("*"*20)
    print(next(g))  # 输出res:None，返回4
    ```

### 参数前加*

+ 加一个*，表示可以输入任意多参数

    ```python
    >>> def multiply(*args):
    ...     total = 1
    ...     for arg in args:
    ...         total *= arg
    ...     return total
    ...
    >>> multiply(2, 3)
    6
    >>> multiply(2, 3, 4, 5, 6)
    720
    ```

+ 加两个*，表示可以输入任意多的关键字和参数

    ```python
    >>> def accept(**kwargs):
    ...     for keyword, value in kwargs.items():
    ...         print "%s => %r" % (keyword, value)
    ...
    >>> accept(foo='bar', spam='eggs')
    foo => 'bar'
    spam => 'eggs'
    ```

# 笔试

+ 牛客网：不允许print，没有报错信息。没有list.copy()函数，需要复制数组建议`new_list = list[1][:]`。

# 面试

+ 面试遇到算法题，**必须先与面试官讨论并确定要求**，如是否允许额外开空间等，确认思路后再写代码。
+ [公司题库](https://www.nowcoder.com/contestRoom?from=cyc_github)
+ [OS、SQL、计网、Python、Git](https://github.com/Niuyuhang03/Waking-Up)
+ [OS、SQL、计网、Linux](https://github.com/Niuyuhang03/CS-Notes)
+ [ML、DL、面经](hhttps://github.com/Niuyuhang03/Deep-Learning-Interview-Book)
+ [DL](https://zhuanlan.zhihu.com/p/48374690)
+ [面经](https://github.com/Niuyuhang03/interview_internal_reference)

# 面经

+ 百度算法：两个题，都简单，但题目描述有问题，迷宫行列给反了。。。数据强调实数注意小数，用C处理输入的是整数还是小数比较烦。
+ 美团推荐算法：没考机器学习。5个题，简单题用dp会卡超时。。。。排列组合考了两个题，暂时不会算。图题复杂。
  + 一面：问最近项目，问很多
  + python 多线程 yield 函数里参数前加* ，我提到java写过多线程。过拟合，正则化，梯度延迟，梯度爆炸，梯度消失，优化函数adam
  + java关键字violate（类似）
  + 写了一个排序，给成绩排序，我写的计数排序，不过可能稍有问题
+ 百度机器学习：小题30个选择，NLP+算法。简答NLP，设计bert、word2vec、lstm。编程两个，第一个简单，第二个图超时。